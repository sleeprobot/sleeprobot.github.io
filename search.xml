<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IntelliJ IDEA2020.2最新破解教程</title>
    <url>/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>特别申明：本教程 IntelliJ IDEA 破解补丁、激活码均收集于网络，请勿商用，仅供个人学习使用，如有侵权，请联系作者删除。<strong>有条件，还请支持正版。</strong></p>
<a id="more"></a>

<p>本教程包含了idea安装版和免安装版两个版本的破解操作，大家可以按需选择。</p>
<p>废话不多说，直接开整！</p>
<h1 id="IDEA安装版"><a href="#IDEA安装版" class="headerlink" title="IDEA安装版"></a>IDEA安装版</h1><p>要安装IDEA，那肯定得有安装包才行，所以，需要先下载安装包。</p>
<h2 id="第一步：下载IDEA2020-2-2版本的安装包"><a href="#第一步：下载IDEA2020-2-2版本的安装包" class="headerlink" title="第一步：下载IDEA2020.2.2版本的安装包"></a>第一步：下载IDEA2020.2.2版本的安装包</h2><p>官网下载地址：<a href="https://download-cf.jetbrains.com/idea/ideaIU-2020.2.2.exe">https://download-cf.jetbrains.com/idea/ideaIU-2020.2.2.exe</a> </p>
<p>如果不想去官网下载的，请移步至文章末尾。</p>
<h2 id="第二步：安装以及破解IDEA"><a href="#第二步：安装以及破解IDEA" class="headerlink" title="第二步：安装以及破解IDEA"></a>第二步：安装以及破解IDEA</h2><ol>
<li><p>下载完成之后，双击<code>ideaIU-2020.2.2.exe</code>，打开安装软件；</p>
<blockquote>
<p>PS：如果有安装老版本的软件，请先卸载</p>
</blockquote>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004160607626-1601798859608.png" alt="image-20201004160607626"></p>
</li>
<li><p>选择安装目录，想要启动得快一点，建议安装在SSD硬盘上</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004160856734.png" alt="image-20201004160856734"></p>
</li>
<li><p>按自己电脑配置勾选，4G内存以上的电脑，一般都是64位操作系统。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004161331545.png" alt="image-20201004161331545"></p>
</li>
<li><p>点击<code>Next</code>后，再点击<code>Install</code>，耐心等待安装完成。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004161515618.png" alt="image-20201004161515618"></p>
</li>
<li><p>安装完成后，勾选<code>Run IntelliJ IDEA</code>，点击<code>Finish</code>运行软件。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004162417628.png" alt="image-20201004162417628"></p>
</li>
<li><p>点击<code>Finish</code>之后，会先弹出一个注册框，勾选<code>Evaluate for free</code>，点击<code>Evaluate</code>：</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004163035711.png" alt="image-20201004163035711"></p>
<p>如果你的IDEA已经过期，点击<code>Evaluate</code>按钮之后，会弹出如下提示框，请点击<code>OK</code>，就可以进入主页面了：</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004163323380.png" alt="image-20201004163323380"></p>
<p>如果没有<code>OK</code>按钮，你就选第一个<code>Enter Key</code>，进去之后选择试用，就能进入主页面了。</p>
</li>
<li><p>进入主页面后，将补丁拖入主页面（注意是拖入，不要解压）。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004164108647.png" alt="image-20201004164108647"></p>
</li>
<li><p>如果你不能将补丁拖入主页面，那么请重启IDEA，新建一个Java项目，写一个空的main方法，再次将补丁拖入IDEA界面。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004222834226.png" alt="image-20201004222834226"></p>
</li>
<li><p>拖入补丁后，会弹出提示框，提示重启IDEA，点击<code>Restart</code>重启IDEA。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004174451478.png" alt="image-20201004174451478"></p>
</li>
<li><p>配置助手会提示你，需要使用哪种激活方式，这里我们选择默认的<code>Activation Code</code>，通过注册码来激活：</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004181430957.png" alt="image-20201004181430957"></p>
<p>将《JetbrainsAgent安装参数.txt》中的内容复制到<code>安装参数</code>的输入框中，然后点击<code>为IDEA安装</code>，会弹出如下提示框：</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004181855063.png" alt="image-20201004181855063"></p>
</li>
<li><p>点击<code>是</code>，重启IDEA即可。</p>
</li>
</ol>
<h2 id="第三步：验证是否激活成功"><a href="#第三步：验证是否激活成功" class="headerlink" title="第三步：验证是否激活成功"></a>第三步：验证是否激活成功</h2><ol>
<li><p>进入 IDEA 界面后，点击<code>Help</code> -&gt; <code>Register</code>查看：</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004220759310.png" alt="image-20201004220759310"></p>
</li>
<li><p>可以看到，已经成功激活至2089年，为确保不失效，请勿随意更新。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004221209840.png" alt="image-20201004221209840"></p>
</li>
</ol>
<p>至此，激活完成！</p>
<h1 id="IDEA免安装版"><a href="#IDEA免安装版" class="headerlink" title="IDEA免安装版"></a>IDEA免安装版</h1><p>和安装版一样，我们同样需要下载软件，不过这次下载的是软件压缩包。</p>
<h2 id="第一步：去官网下载软件压缩包"><a href="#第一步：去官网下载软件压缩包" class="headerlink" title="第一步：去官网下载软件压缩包"></a>第一步：去官网下载软件压缩包</h2><p>官网下载地址：<a href="https://download-cf.jetbrains.com/idea/ideaIU-2020.2.2.win.zip">https://download-cf.jetbrains.com/idea/ideaIU-2020.2.2.win.zip</a></p>
<p>如果不想去官网下载，可以移步至文章末尾。</p>
<h2 id="第二步：解压并打开软件"><a href="#第二步：解压并打开软件" class="headerlink" title="第二步：解压并打开软件"></a>第二步：解压并打开软件</h2><ol>
<li><p>解压<code>ideaIU-2020.2.2.win.zip</code>，解压后的目录结构如下：</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004233929486.png" alt="image-20201004233929486"></p>
</li>
<li><p>进入<code>bin</code>目录，找到<code>idea64.exe</code>文件，双击运行。</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004234017714.png" alt="image-20201004234017714"></p>
</li>
<li><p>之后的破解步骤，就和安装版的一致了，详情请查看安装版的破解步骤（从安装版的<strong>第二步的第6点</strong>开始），这里就不赘述了。</p>
</li>
</ol>
<h1 id="获取软件及破解补丁"><a href="#获取软件及破解补丁" class="headerlink" title="获取软件及破解补丁"></a>获取软件及破解补丁</h1><p>扫码关注微信公众号，回复”idea破解“即可获取2020.2.2版本的idea软件及破解补丁：</p>
<p><img data-src="/2020/10/04/IntelliJ-IDEA2020-2%E6%9C%80%E6%96%B0%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/image-20201004235651650.png" alt="扫码关注微信公众号，获取你想要的资源"></p>
]]></content>
      <categories>
        <category>电脑软件</category>
        <category>办公软件</category>
      </categories>
      <tags>
        <tag>电脑软件</tag>
        <tag>办公软件</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK环境变量配置</title>
    <url>/2020/09/28/JDK%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="JDK环境变量配置"><a href="#JDK环境变量配置" class="headerlink" title="JDK环境变量配置"></a>JDK环境变量配置</h1><ol>
<li>计算机-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</li>
<li>系统变量-&gt;新建<code>JAVA_HOME</code>变量，变量值：JDK的安装目录<a id="more"></a></li>
<li>在系统变量中找到<code>Path</code>变量，新增两个变量值<code>%JAVA＿HOME%\bin;%JAVA_HOME%\jre\bin;</code>（path的变量值末尾如果没有;号，先输入;号在输入变量值。win10系统把变量全部列了出来，不用手动加;号）</li>
<li>在系统变量新建<code>CLASSPATH</code>变量，变量值：<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code>（注意最前面的一个点）</li>
<li>检验是否配置成功，<code>win+R</code>输入<code>cmd</code>回车，然后再dos窗口输入<code>java</code>回车，出现如下图即配置成功：</li>
</ol>
<p><img data-src="/2020/09/28/JDK%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/1541949583293.png" alt="1541949583293"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH连接到GitHub</title>
    <url>/2020/10/01/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/</url>
    <content><![CDATA[<h1 id="关于SSH"><a href="#关于SSH" class="headerlink" title="关于SSH"></a>关于SSH</h1><p>使用 SSH 协议可以连接远程服务器和服务并向它们验证。 利用 SSH 密钥可以连接 GitHub，而无需在每次访问时提供用户名或密码。</p>
<a id="more"></a>

<h1 id="检查现有SSH密钥"><a href="#检查现有SSH密钥" class="headerlink" title="检查现有SSH密钥"></a>检查现有SSH密钥</h1><p>在生成SSH密钥之前，你可以检查是否有任何现有的 SSH 密钥。</p>
<p><strong>Windows || Mac || Linux</strong></p>
<ol>
<li><p>Windows下打开Git Bash，Mac和Linux则是打开Terminal（终端）</p>
</li>
<li><p>输入<code>ls -al ~/.sh</code>以检查是否存在现有SSH密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br><span class="line">total 34</span><br><span class="line">drwxr-xr-x 1 username 197121    0  9月 16 15:36 ./</span><br><span class="line">drwxr-xr-x 1 username 197121    0  9月 30 23:33 ../</span><br><span class="line">-rw-r--r-- 1 username 197121 2602  9月 16 15:29 id_rsa</span><br><span class="line">-rw-r--r-- 1 username 197121  573  9月 16 15:29 id_rsa.pub</span><br><span class="line">-rw-r--r-- 1 username 197121  406  9月 16 15:36 known_hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查目录列表以查看是否已经有 SSH 公钥。 默认情况下，公钥的文件名是以下之一：</p>
<ul>
<li><em>id_rsa.pub</em></li>
<li><em>id_ecdsa.pub</em></li>
<li><em>id_ed25519.pub</em></li>
</ul>
</li>
</ol>
<p>如果您没有现有的公钥和私钥对，或者不想使用任何可用于连接到 GitHub 的密钥对，则生成新的 SSH 密钥。</p>
<p>如果您看到列出的现有公钥和私钥对（例如 <em>id_rsa.pub</em> 和 <em>id_rsa</em>），并且您希望使用它们连接到 GitHub，则可以将 SSH 密钥添加到 ssh-agent。</p>
<p>如果看到<code>~/.ssh</code>不存在，那么就需要生成新的SSH密钥，生成密钥时，会自动创建。</p>
<h1 id="生成新SSH密钥并添加到ssh-agent"><a href="#生成新SSH密钥并添加到ssh-agent" class="headerlink" title="生成新SSH密钥并添加到ssh-agent"></a>生成新SSH密钥并添加到ssh-agent</h1><p>检查现有 SSH 密钥后，您可以生成新 SSH 密钥以用于身份验证，然后将其添加到 ssh-agent。</p>
<h2 id="生成新SSH密钥"><a href="#生成新SSH密钥" class="headerlink" title="生成新SSH密钥"></a>生成新SSH密钥</h2><ol>
<li><p>Windows下打开Git Bash，Mac或者Linux下打开Terminal。</p>
</li>
<li><p>粘贴下面的文本（替换为你的 GitHub 电子邮件地址）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"><span class="comment"># -t rsa : t是type的缩写，指定密钥的类型，一种是RSA，一种是DSA，GitHub目前已经不支持DSA了。ssh-keygen默认使用RSA密钥</span></span><br><span class="line"><span class="comment"># -b 4096 ：b是bit的缩写，指定的密钥长度。对于RSA密钥，最小要求768位，默认是2048位。命令中的4096指的是RSA密钥长度为4096位。</span></span><br><span class="line"><span class="comment"># -C &quot;邮箱&quot; ：C是comment的缩写。-C表示要提供一个新注释，用于识别这个密钥，所以“”里面不一定非要填邮箱，可以是任何内容，邮箱仅仅是识别用的key</span></span><br></pre></td></tr></table></figure>

<p>会出现如下提示：<code>这将创建以所提供的电子邮件地址为标签的新 SSH 密钥</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Generating public&#x2F;private rsa key pair.</span><br></pre></td></tr></table></figure>
</li>
<li><p>提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 接受默认文件位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Enter a file in which to save the key (&#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa):[Press enter]</span><br></pre></td></tr></table></figure>
</li>
<li><p>在提示时输入安全密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure>

<p>这里，我们先不填，直接回车，出现类似如下信息，SSH密钥就生成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;asua&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;asua&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:VlPdd6hxwLDZ3ef9cT&#x2F;kmTTySNct9YR3Cv&#x2F;MArvap&#x2F;g hahaha@gmail.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 4096]----+</span><br><span class="line">|          .ooo o |</span><br><span class="line">|           &#x3D;o.+o+|</span><br><span class="line">|          &#x3D; o+o X|</span><br><span class="line">|         . ..o *B|</span><br><span class="line">|        S   .o+*B|</span><br><span class="line">|       .    .oO&#x3D;O|</span><br><span class="line">|            ...**|</span><br><span class="line">|           o ....|</span><br><span class="line">|          ooEo   |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="将SSH密钥添加到ssh-agent"><a href="#将SSH密钥添加到ssh-agent" class="headerlink" title="将SSH密钥添加到ssh-agent"></a>将SSH密钥添加到ssh-agent</h2><p>将新 SSH 密钥添加到 ssh-agent 以管理密钥之前，要确保你已经拥有SSH密钥。</p>
<p>将SSH密钥添加到ssh-agent的步骤：</p>
<ol>
<li><p>确保 ssh-agent 正在运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在后台启动 ssh-agent</span></span><br><span class="line">$ <span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line">Agent pid 1171</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 SSH 私钥添加到 ssh-agent。 如果您创建了不同名称的密钥，或者您要添加不同名称的现有密钥，请将命令中的 <em>id_rsa</em> 替换为您的私钥文件的名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">Identity added: /c/Users/asua/.ssh/id_rsa (hahaha@gmail.com)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>添加完成！</p>
<h1 id="添加SSH密钥到GitHub账户"><a href="#添加SSH密钥到GitHub账户" class="headerlink" title="添加SSH密钥到GitHub账户"></a>添加SSH密钥到GitHub账户</h1><p>要配置 GitHub 帐户使用新的（或现有）SSH 密钥，您还需要将其添加到 GitHub 帐户。</p>
<ol>
<li><p>将SSH密钥复制到剪贴板</p>
<p>如果您的 SSH 密钥文件与示例代码不同，请修改文件名以匹配您当前的设置。 在复制密钥时，请勿添加任何新行或空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>如果 <code>clip</code> 不可用，可找到隐藏的 <code>.ssh</code> 文件夹，在常用的文本编辑器中打开该文件，并将其复制到剪贴板。</p>
</li>
<li><p>在任何页面的右上角，单击您的个人资料照片，然后单击 <strong>Settings（设置）</strong>。</p>
<p><img data-src="/2020/10/01/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/image-20201001192242182.png" alt="image-20201001192242182"></p>
</li>
<li><p>在用户设置侧边栏中，单击 <strong>SSH and GPG keys（SSH 和 GPG 密钥）</strong>。</p>
<p><img data-src="/2020/10/01/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/image-20201001192359985.png" alt="image-20201001192359985"></p>
</li>
<li><p>单击 <strong>New SSH key（新 SSH 密钥）</strong>或 <strong>Add SSH key（添加 SSH 密钥）</strong>。</p>
<p><img data-src="/2020/10/01/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/image-20201001192526763.png" alt="image-20201001192526763"></p>
</li>
<li><p>在 “Title”（标题）字段中，为新密钥添加描述性标签。 例如，如果您使用的是个人 Mac，此密钥名称可能是 “Personal MacBook Air”。</p>
</li>
<li><p>将密钥粘贴到 “Key”（密钥）字段。</p>
<p><img data-src="/2020/10/01/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/image-20201001192647422.png" alt="image-20201001192647422"></p>
</li>
<li><p>单击 <strong>Add SSH key（添加 SSH 密钥）</strong>。</p>
</li>
<li><p>如有提示，请确认您的 GitHub 密码。</p>
<p><img data-src="/2020/10/01/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/image-20201001192809676.png" alt="image-20201001192809676"></p>
</li>
</ol>
<h1 id="测试SSH连接"><a href="#测试SSH连接" class="headerlink" title="测试SSH连接"></a>测试SSH连接</h1><p>设置 SSH 密钥并将其添加到您的 GitHub 帐户后，你可以测试连接。</p>
<p>测试连接时，您将需要使用密码（即您之前创建的 SSH 密钥密码）验证此操作。</p>
<ol>
<li><p>Windows打开Git Bash，Mac和Linux打开Terminal（终端）。</p>
</li>
<li><p>输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试通过ssh连接到GitHub</span></span><br><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>可能会看到类似如下的警告：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; The authenticity of host <span class="string">&#x27;github.com (IP ADDRESS)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">&gt; RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="string">&gt; Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>

<p>或类似如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; The authenticity of host <span class="string">&#x27;github.com (IP ADDRESS)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="string">&gt; Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证您看到的消息中的指纹匹配步骤 2 中的消息之一，然后输入 <code>yes</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证生成的消息包含您的用户名。</p>
</li>
</ol>
<h1 id="使用SSH密钥密码"><a href="#使用SSH密钥密码" class="headerlink" title="使用SSH密钥密码"></a>使用SSH密钥密码</h1><p>你可以保护 SSH 密钥并配置身份验证代理，这样就不必在每次使用 SSH 密钥时重新输入密码。</p>
<p>使用 SSH 密钥时，如果有人获得你计算机的访问权限，他们也可以使用该密钥访问每个系统。 要添加额外的安全层，可以向 SSH 密钥添加密码。 可以使用 <code>ssh-agent</code> 安全地保存密码，从而不必重新输入。</p>
<h2 id="添加或更改密码"><a href="#添加或更改密码" class="headerlink" title="添加或更改密码"></a>添加或更改密码</h2><p>通过输入以下命令，您可以更改现有私钥的密码而无需重新生成密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -p</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> the key is (/c/Users/asua/.ssh/id_rsa): <span class="comment"># 如果你的密钥就在默认位置，直接回车就行，如果不是，就手动输入</span></span><br><span class="line">Key has comment <span class="string">&#x27;hahaha@gmail.com&#x27;</span> <span class="comment"># 之前生成密钥时，我输入的内容</span></span><br><span class="line">Enter new passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment"># 输入新密码</span></span><br><span class="line">Enter same passphrase again: <span class="comment"># 再次输入密码</span></span><br><span class="line">Your identification has been saved with the new passphrase. <span class="comment"># 身份信息和密码一起保存</span></span><br></pre></td></tr></table></figure>

<p>如果您的密钥已有密码，系统将提示您输入该密码，然后才能更改为新密码。</p>
<h2 id="在-Git-for-Windows上自启动ssh-agent"><a href="#在-Git-for-Windows上自启动ssh-agent" class="headerlink" title="在 Git for Windows上自启动ssh-agent"></a>在 Git for Windows上自启动<code>ssh-agent</code></h2><p>你可以在打开 bash 或 Git shell 时自动运行 <code>ssh-agent</code>。 复制以下行并将其粘贴到 Git shell 中的 <code>~/.profile</code> 或 <code>~/.bashrc</code> 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">env=~/.ssh/agent.env</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">agent_load_env</span></span> () &#123; <span class="built_in">test</span> -f <span class="string">&quot;<span class="variable">$env</span>&quot;</span> &amp;&amp; . <span class="string">&quot;<span class="variable">$env</span>&quot;</span> &gt;| /dev/null ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">agent_start</span></span> () &#123;</span><br><span class="line">    (<span class="built_in">umask</span> 077; ssh-agent &gt;| <span class="string">&quot;<span class="variable">$env</span>&quot;</span>)</span><br><span class="line">    . <span class="string">&quot;<span class="variable">$env</span>&quot;</span> &gt;| /dev/null ; &#125;</span><br><span class="line"></span><br><span class="line">agent_load_env</span><br><span class="line"></span><br><span class="line"><span class="comment"># agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not running</span></span><br><span class="line">agent_run_state=$(ssh-add -l &gt;| /dev/null 2&gt;&amp;1; <span class="built_in">echo</span> $?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;<span class="variable">$SSH_AUTH_SOCK</span>&quot;</span> ] || [ <span class="variable">$agent_run_state</span> = 2 ]; <span class="keyword">then</span></span><br><span class="line">    agent_start</span><br><span class="line">    ssh-add</span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$SSH_AUTH_SOCK</span>&quot;</span> ] &amp;&amp; [ <span class="variable">$agent_run_state</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">    ssh-add</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> env</span><br></pre></td></tr></table></figure>

<p>如果你的私钥没有存储在默认位置之一（如 <code>~/.ssh/id_rsa</code>），你需要告知 SSH 身份验证代理其所在位置。 要将密钥添加到 ssh-agent，请输入 <code>ssh-add ~/path/to/my_key</code>。</p>
<blockquote>
<p>如果想要 <code>ssh-agent</code> 在一段时间后忘记您的密钥，可通过运行 <code>ssh-add -t &lt;seconds&gt;</code> 进行配置。</p>
</blockquote>
<p>现在，当您初次运行 Git Bash 时，系统将提示您输入密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Initializing new SSH agent...</span><br><span class="line">&gt; succeeded</span><br><span class="line">&gt; Enter passphrase <span class="keyword">for</span> /c/Users/you/.ssh/id_rsa:</span><br><span class="line">&gt; Identity added: /c/Users/you/.ssh/id_rsa (/c/Users/you/.ssh/id_rsa)</span><br><span class="line">&gt; Welcome to Git (version 1.6.0.2-preview20080923)</span><br><span class="line">&gt;</span><br><span class="line">&gt; Run <span class="string">&#x27;git help git&#x27;</span> to display the <span class="built_in">help</span> index.</span><br><span class="line">&gt; Run <span class="string">&#x27;git help &#x27;</span> to display <span class="built_in">help</span> <span class="keyword">for</span> specific commands.</span><br></pre></td></tr></table></figure>

<p><code>ssh-agent</code> 进程将继续运行，直到您注销、关闭计算机或终止该进程。</p>
<p>如果没有 <code>~/.profile</code> 或 <code>~/.bashrc</code> 文件，则自己创建一个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ touch ~/.profile <span class="comment"># 在/c/Users/username路径下新建.profile文件，就是和.ssh文件在同一个目录下</span></span><br></pre></td></tr></table></figure>

<p>用文本编辑器（Notepad++或者vim）打开<code>.profile</code>文件，将上面的脚本代码复制到<code>.profile</code>文件中保存后退出，重新打开Git Bash后，输入SSH的密码即可。</p>
<h1 id="一台机器上管理多个GitHub账号的SSH密钥"><a href="#一台机器上管理多个GitHub账号的SSH密钥" class="headerlink" title="一台机器上管理多个GitHub账号的SSH密钥"></a>一台机器上管理多个GitHub账号的SSH密钥</h1><p>如果你在一台机器使用两个github账号（比如私人账号abc和工作账号xyz），两个帐号用不同的SSH KEY，还需要编辑一下配置文件~/.ssh/config：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host personal.github.com  </span><br><span class="line">    HostName github.com  </span><br><span class="line">    User git  </span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;personal_rsa  </span><br><span class="line">    </span><br><span class="line">Host work.github.com  </span><br><span class="line">    HostName github.com  </span><br><span class="line">    User git  </span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;work_rsa</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Host： “personal.github.com”是一个”别名”，可以随意命名。</p>
</li>
<li><p>HostName：比如我工作的git仓储地址是<code>git@code.sleep.com:username/repo_name.git</code>, 那么我的HostName就要填”sleep.com”；</p>
</li>
<li><p>IdentityFile： 所使用的公钥文件;</p>
</li>
</ul>
<p>配置完毕，用下面的命令测试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@personal.github.com</span><br><span class="line">ssh -T git@work.github.com</span><br><span class="line"><span class="comment"># 注： @符号后面的&quot;personal.github.com&quot;就是在~/.ssh/config文件中指定的&quot;Host&quot;项</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>为已经检出的repository指定github账号：</p>
<p>在已经检出的repos目录下执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config  user.name <span class="string">&quot;your-id&quot;</span></span><br><span class="line">git config  user.email <span class="string">&quot;your-id@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改.git/config并找到<code>[remote &quot;origin&quot;]</code>,修改<code>url</code>的值为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[remote <span class="string">&quot;origin&quot;</span>]   </span><br><span class="line">    url = git@personal.github.com:user_name/repos_name.git</span><br></pre></td></tr></table></figure>

<p>其中, <code>personal.github.com</code>就是在配置文件~/.ssh/config中的<code>Host</code>项, 设置完成后, 在这个工程目录<code>git push</code>会自动以此git帐号提交代码。</p>
</li>
<li><p>使用指定账号clone已存在的repository：</p>
<ul>
<li><p>使用指定账号clone一个已经存在的repos:<br> <code>git clone git@personal.github.com:user_name/repos_name.git</code>, 上面命令中的”personal.github.com”就是在～/.ssh/config文件中指定的”Host”项, “user_name”是指定提交代码的账户名。</p>
</li>
<li><p>然后还需要<code>git config</code>一下user.name和user.email, 进入repository目录执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name your_name</span><br><span class="line">git config user.email your_email</span><br></pre></td></tr></table></figure>

<p>以后在此repos下<code>git push origin master</code>就是使用指定的用户push.</p>
</li>
</ul>
</li>
<li><p>使用指定账号<code>git init</code>新的repository：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">$ git remote add origin git@personal.github.com:user_name/testing.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2020/09/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数据库和SQL概述"><a href="#数据库和SQL概述" class="headerlink" title="数据库和SQL概述"></a>数据库和SQL概述</h1><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><ul>
<li>实现数据持久化管理</li>
<li>使用完整的管理系统统一管理，易于查询</li>
</ul>
<a id="more"></a>

<h2 id="数据库的概念"><a href="#数据库的概念" class="headerlink" title="数据库的概念"></a>数据库的概念</h2><p>DB 数据库（database）：存储数据的“仓库”。</p>
<p>DBMS：数据库管理系统（Database Management System ）数据库是通过DBMS创建和操作的容器。</p>
<p>SQL：结构化查询语言（Structure Query Language）专门用来与数据库通信的语言</p>
<p>常见的数据库管理系统：MySQL、Oracle、DB2、SQLserve</p>
<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p>数据库是不认识java语言的，但是我们同样要与数据库交互，这是需要使用到数据库认识的语言SQL语句，它是数据库的代码。</p>
<p>结构化查询语言（Structure Query Language）简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>
<p>创建数据库、创建数据表、向数据表中添加一条条数据信息均需要使用SQL语句。</p>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>DML（Data Manipulation Language）：数据操纵语言，用于添加、删除、修改、查询数据库记录，并检查数据完整性。包括如下SQL语句等：</p>
<ul>
<li>INSERT：添加数据到数据库中</li>
<li>UPDATE：修改数据库中的数据</li>
<li>DELETE：删除数据库中的数据</li>
<li>SELECT：选择（查询）数据</li>
<li><strong>SELECT 是SQL语言中的基础，最为重要</strong></li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>DDL（Data Definition Language）：数据定义语句，用于库和表的创建、修改、删除。包括如下SQL语句等：</p>
<ul>
<li>CREATE TABLE：创建数据库表</li>
<li>ALTER TABLE：更改表结构、添加、删除、修改列长度</li>
<li>DROP TABLE：删除表</li>
<li>CREATE INDEX：在表上建立索引</li>
<li>DROP INDEX：删除索引</li>
</ul>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL（Data Control Language）：数据控制语句，用于定义用户的访问权限和安全级别。包括如下SQL语句等：</p>
<ul>
<li>GRANT：授予访问权限</li>
<li>REVOKE：撤销访问权限</li>
<li>COMMIT：提交事务处理</li>
<li>ROLLBACK：事务处理回退（回滚）</li>
<li>SAVEPOINT：设置保存点</li>
<li>LOCK：对数据库的特定部分进行锁定</li>
</ul>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>DQL（Data Query Language）：数据查询语言，用来查询数据库中表的记录。关键字：SELECT，FROM，WHERE等。</p>
<h1 id="MySQL的安装与使用"><a href="#MySQL的安装与使用" class="headerlink" title="MySQL的安装与使用"></a>MySQL的安装与使用</h1><h2 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h2><ul>
<li>Windows版本</li>
<li>Linux版本</li>
</ul>
<h2 id="启动和停止MySQL服务"><a href="#启动和停止MySQL服务" class="headerlink" title="启动和停止MySQL服务"></a>启动和停止MySQL服务</h2><ul>
<li>Windows<ul>
<li>方式一：通过计算机管理方式；右击计算机-&gt;管理-&gt;服务-&gt;启动或停止MySQL服务</li>
<li>方式二：通过命令行方式；启动：net start mysql服务名；停止：net stop mysql服务名</li>
</ul>
</li>
<li>Linux<ul>
<li>启动：service mysql（mysqld） start</li>
<li>停止：service mysql（mysqld） stop</li>
<li>状态：service mysql（mysqld） status</li>
</ul>
</li>
</ul>
<h2 id="MySQL服务端的登录和退出"><a href="#MySQL服务端的登录和退出" class="headerlink" title="MySQL服务端的登录和退出"></a>MySQL服务端的登录和退出</h2><ul>
<li><p>登录</p>
<p>mysql -u用户名 -p密码</p>
</li>
<li><p>远程登录</p>
<p>mysql -h 主机名 -p 端口号 -u用户名 -p密码</p>
</li>
<li><p>退出</p>
<p>exit或者quit</p>
</li>
</ul>
<h2 id="MySQL数据库的使用"><a href="#MySQL数据库的使用" class="headerlink" title="MySQL数据库的使用"></a>MySQL数据库的使用</h2><ul>
<li>不区分大小写（Linux上区分，可以通过配置文件修改）<strong>建议关键字全部大写</strong></li>
<li>每句话使用;或者\g结尾</li>
<li>各子句一般分行写</li>
<li>关键字不能缩写也不能分行</li>
<li>用缩进提高语句的可读性</li>
</ul>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="查看MySQL中有哪些数据库"><a href="#查看MySQL中有哪些数据库" class="headerlink" title="查看MySQL中有哪些数据库"></a>查看MySQL中有哪些数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<h3 id="使用一个数据库"><a href="#使用一个数据库" class="headerlink" title="使用一个数据库"></a>使用一个数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE 数据库名称</span><br></pre></td></tr></table></figure>

<h3 id="查看当前使用的数据库中的表"><a href="#查看当前使用的数据库中的表" class="headerlink" title="查看当前使用的数据库中的表"></a>查看当前使用的数据库中的表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<h3 id="查看指定数据库中的表"><a href="#查看指定数据库中的表" class="headerlink" title="查看指定数据库中的表"></a>查看指定数据库中的表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW TABLES FROM 数据库名;</span><br></pre></td></tr></table></figure>

<h3 id="新建一个数据库"><a href="#新建一个数据库" class="headerlink" title="新建一个数据库"></a>新建一个数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建数据库 数据库中数据的编码采用的是安装数据库是指定的默认编码 utf8</span><br><span class="line">CREATE DATABASE 数据库名;</span><br><span class="line">#创建数据库 并指定数据库中数据的编码</span><br><span class="line">CREATE DATABASE 数据库名 CHARACTER SET utf8</span><br></pre></td></tr></table></figure>

<h3 id="查看当前选择的数据库"><a href="#查看当前选择的数据库" class="headerlink" title="查看当前选择的数据库"></a>查看当前选择的数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>

<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student_info(</span><br><span class="line">	id int,</span><br><span class="line">	name varchar(20));</span><br></pre></td></tr></table></figure>

<h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>

<h3 id="查看表中所有记录"><a href="#查看表中所有记录" class="headerlink" title="查看表中所有记录"></a>查看表中所有记录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>

<h3 id="向表中插入记录"><a href="#向表中插入记录" class="headerlink" title="向表中插入记录"></a>向表中插入记录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(列名1, 列名2, ..., 列名n) VALUES(列1值, 列2值, ..., 列n值);</span><br></pre></td></tr></table></figure>

<p><strong>注意：插入varchar 或 date 类型的数据要用 英文单引号 引起来</strong></p>
<h1 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h1><p>使用的数据表</p>
<h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *|&#123;[DISTINCT] column|expression [alias],...&#125; FROM 表名</span><br></pre></td></tr></table></figure>

<ul>
<li>SELECT 标识选择哪些列</li>
<li>FROM 标识从哪个表中选</li>
</ul>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>查询的结果是一个虚拟的表格</li>
</ol>
<h3 id="查询全部列"><a href="#查询全部列" class="headerlink" title="查询全部列"></a>查询全部列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>

<h3 id="查询特定的列"><a href="#查询特定的列" class="headerlink" title="查询特定的列"></a>查询特定的列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id, name FROM student;</span><br></pre></td></tr></table></figure>

<h3 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98;</span><br></pre></td></tr></table></figure>

<h3 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW();</span><br></pre></td></tr></table></figure>

<h2 id="查询时给列取别名"><a href="#查询时给列取别名" class="headerlink" title="查询时给列取别名"></a>查询时给列取别名</h2><p><strong>在别名中包含空格或特殊的字符时，使用英文双引号包裹别名</strong></p>
<p>使用别名的好处：</p>
<ol>
<li>便于理解</li>
<li>如果要查询的字段有重名的情况，使用别名可以区分开来</li>
</ol>
<h3 id="使用as"><a href="#使用as" class="headerlink" title="使用as"></a>使用as</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名1 AS &quot;列名1别名&quot;, 列名2 as &quot;列名2别名&quot; FROM 表名;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 100%98 as &quot;结果&quot;;</span><br><span class="line">SELECT last_name AS &quot;姓&quot;, first_name AS &quot;名&quot; FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="使用空格"><a href="#使用空格" class="headerlink" title="使用空格"></a>使用空格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名1 &quot;列名1别名&quot;, 列名2 &quot;列名2别名&quot; FROM 表名; </span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询salary，显示结果为 out_put</span><br><span class="line">SELECT salary &quot;out_put&quot; FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="查询去重"><a href="#查询去重" class="headerlink" title="查询去重"></a>查询去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 字段名 FROM 表名;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工表中涉及到的所有部门编号</span><br><span class="line">SELECT DISTINCT department_id FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="加号-的作用"><a href="#加号-的作用" class="headerlink" title="加号(+)的作用"></a>加号(+)的作用</h2><p>Java中的 + 号：</p>
<ol>
<li>运算符，两个操作数都为数值型</li>
<li>连接符，只要有一个操作数为字符串，就会被当做连接符使用</li>
</ol>
<p>MySQL中的 + 号：仅仅只有一个功能，用作运算，即运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 直接运算</span><br><span class="line">SELECT 数值 + 数值;</span><br><span class="line"></span><br><span class="line"># 先试图将字符转换成数值，如果转换成功，则继续运算，否则转换成0，在做运算</span><br><span class="line">SELECT 字符 + 数值;</span><br><span class="line"></span><br><span class="line"># 结果都为null</span><br><span class="line">SELECT NULL + 值;</span><br></pre></td></tr></table></figure>

<h2 id="CONCAT函数"><a href="#CONCAT函数" class="headerlink" title="CONCAT函数"></a>CONCAT函数</h2><p>功能：拼接字符，相当于java中的 “1” + “23” = “123”;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(字符1, 字符2, 字符3,...);</span><br></pre></td></tr></table></figure>

<h2 id="IFNULL函数"><a href="#IFNULL函数" class="headerlink" title="IFNULL函数"></a>IFNULL函数</h2><p>功能：判断某字段或者表达式是否为null，如果为null返回指定的值，否则返回原本的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果commission_pct列为null则返回0</span><br><span class="line">SELECT IFNULL(commission_pct, 0) FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="ISNULL函数"><a href="#ISNULL函数" class="headerlink" title="ISNULL函数"></a>ISNULL函数</h2><p>功能：判断某字段或表达式是否为null，如果是则返回1，否则返回0</p>
<h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><p>过滤：使用 WHERE 子句，将不满足条件的行（记录）过滤掉</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 WHERE 筛选条件;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">符号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">比较(条件)运算符</td>
<td align="center">&gt;、&lt;、&gt;=、&lt;=、=、&lt;&gt;(!=)</td>
<td align="center">大于、小于、大于等于、小于等于、等于、不等于</td>
</tr>
<tr>
<td align="center">BETWEEN…AND…</td>
<td align="center"></td>
<td align="center">显示在某一区间的值（包含头尾）</td>
</tr>
<tr>
<td align="center">IN(可能的值的集合)</td>
<td align="center"></td>
<td align="center">显示在in列表中的值，例如：IN(100, 200, 300)</td>
</tr>
<tr>
<td align="center">LIKE 通配符</td>
<td align="center"></td>
<td align="center">模糊查询，Like语句中有两个通配符：%用来匹配多个字符；例如first_name like ‘a%’; _用来匹配一个字符。例如first_name like ‘a_’;</td>
</tr>
<tr>
<td align="center">IS NULL</td>
<td align="center"></td>
<td align="center">判断是否为空；IS NULL判断为空； IS NOT NULL判断不为空</td>
</tr>
<tr>
<td align="center">逻辑运算符</td>
<td align="center">AND（&amp;&amp;）</td>
<td align="center">多个条件同时成立</td>
</tr>
<tr>
<td align="center">逻辑运算符</td>
<td align="center">OR（||）</td>
<td align="center">多个条件任一成立</td>
</tr>
<tr>
<td align="center">逻辑运算符</td>
<td align="center">NOT（！）</td>
<td align="center">不成立或者说去反，例：WHERE NOT（salary &gt; 100）</td>
</tr>
</tbody></table>
<p><strong>注意：为了方便建表，将between…and.. 、in、like、is null归为运算符，可能不是很准确</strong></p>
<h2 id="按条件表达式筛选"><a href="#按条件表达式筛选" class="headerlink" title="按条件表达式筛选"></a>按条件表达式筛选</h2><ol>
<li>查询工资&gt;12000的员工信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	employees </span><br><span class="line">WHERE</span><br><span class="line">	salary &gt; 12000;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询部门编号不等于90的员工名和部门编号</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	department_id </span><br><span class="line">FROM</span><br><span class="line">	employees </span><br><span class="line">WHERE</span><br><span class="line">	department_id &lt;&gt; 90;</span><br></pre></td></tr></table></figure>

<h2 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h2><ol>
<li>查询工资在10000到20000之间的员工名、工资以及奖金率</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct </span><br><span class="line">FROM</span><br><span class="line">	employees </span><br><span class="line">WHERE</span><br><span class="line">	salary &gt;&#x3D; 10000 AND salary &lt;&#x3D; 20000;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary,</span><br><span class="line">	commission_pct </span><br><span class="line">FROM</span><br><span class="line">	employees </span><br><span class="line">WHERE</span><br><span class="line">	salary BETWEEN 10000 AND 20000;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询部门编号不是在90到110之间，或者工资高于15000的员工信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	* </span><br><span class="line">FROM </span><br><span class="line">	employees </span><br><span class="line">WHERE </span><br><span class="line">	NOT ( department_id &gt;&#x3D; 90 AND department_id &lt;&#x3D; 110 ) </span><br><span class="line">	OR salary &gt; 15000;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	* </span><br><span class="line">FROM </span><br><span class="line">	employees </span><br><span class="line">WHERE </span><br><span class="line">	NOT ( department_id BETWEEN 90 AND 110) </span><br><span class="line">	OR salary &gt; 15000;</span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><strong>关键字：</strong>LIKE</p>
<p><strong>特点：</strong></p>
<ol>
<li><p>一般和通配符搭配使用</p>
<p>通配符：</p>
<p>%：任意多个字符，包含0个字符</p>
<p>_ ：任意单个字符</p>
</li>
</ol>
<p><strong>案例：</strong></p>
<ol>
<li>查询员工名中包含字符a的员工信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &#39;%a%&#39;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询员工名中第三个字符为m，第五个字符为n的员工名和工资</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	salary</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &#39;__m_n%&#39;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>查询员工名中第二个字符为_的员工名</p>
<p>如果查询的字符为_，这时就需要转义，可以使用<code>\</code>，可以使用ESCAPE，定义一个转义标识</p>
<p>ESCAPE：定义转义标识</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	last_name LIKE &#39;_$_%&#39; ESCAPE &#39;$&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><p>含义：判断某字段的值是否属于IN列表中的某一项</p>
<p>特点：</p>
<ol>
<li>使用IN提高语句简洁度</li>
<li>列表的值类型必须一致或兼容</li>
<li>列表中不支持通配符</li>
</ol>
<p>查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个的员工名和工种编号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE </span><br><span class="line">	job_id IN(&#39;IT_PROG&#39;, &#39;AD_VP&#39;, &#39;AD_PRES&#39;);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	job_id</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	job_id &#x3D; &#39;IT_PROG&#39; OR job_id &#x3D; &#39;AD_VP&#39; OR job_id &#x3D; &#39;AD_PRES&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="IS-NULL"><a href="#IS-NULL" class="headerlink" title="IS NULL"></a>IS NULL</h2><p><strong>=或&lt;&gt;不能用于判断null值；IS NULL 或 IS NOT NULL可以判断null值</strong></p>
<ol>
<li>查询没有奖金的员工名和奖金率</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NULL;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询有奖金的员工名和奖金率</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<h2 id="安全等于-lt-gt"><a href="#安全等于-lt-gt" class="headerlink" title="安全等于&lt;=&gt;"></a>安全等于&lt;=&gt;</h2><ol>
<li>查询没有奖金的员工名和奖金率</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	commission_pct</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	commission_pct &lt;&#x3D;&gt; NULL;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询工资为12000的员工信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	salary &lt;&#x3D;&gt; 12000;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p><strong>IS NULL：仅仅可以判断NULL值，可读性比较高，建议使用</strong></p>
<p><strong>&lt;=&gt;：既可以判断NULL值，又可以判断普通的数据，可读性比较低，不推荐使用</strong></p>
<h1 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h1><p>使用 ORDER BY 子句排序</p>
<ul>
<li>ASC（ascend）：升序</li>
<li>DESC（descend）：降序</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表名</span><br><span class="line">[WHERE 筛选条件]</span><br><span class="line">ORDER BY 排序的字段或表达式;</span><br></pre></td></tr></table></figure>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>ASC代表的是升序，可以省略。</li>
<li>ORDER BY子句可以支持 单个字段、别名、表达式、函数、多个字段</li>
<li>ORDER BY子句在查询语句的最后面，除了LIMIT子句</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="单个字段排序"><a href="#单个字段排序" class="headerlink" title="单个字段排序"></a>单个字段排序</h3><ol>
<li>查询员工表按薪水降序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees ORDER BY salary DESC; </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询部门编号&gt;=90的员工信息，并按员工编号降序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	department_id &gt;&#x3D; 90</span><br><span class="line">ORDER BY employee_id DESC;</span><br></pre></td></tr></table></figure>

<h3 id="按表达式排序"><a href="#按表达式排序" class="headerlink" title="按表达式排序"></a>按表达式排序</h3><ol>
<li>查询员工信息 按年薪降序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *, salary * 12 * (1 + IFNULL(commission_pct, 0))</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY salary * 12 * (1 + IFNULL(commission_pct, 0)) DESC;</span><br></pre></td></tr></table></figure>

<h3 id="按别名排序"><a href="#按别名排序" class="headerlink" title="按别名排序"></a>按别名排序</h3><ol>
<li>查询员工信息，按年薪升序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *, salary * 12 * (1 + IFNULL(commission_pct, 0)) AS 年薪</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY 年薪 ASC;</span><br></pre></td></tr></table></figure>

<h3 id="按函数排序"><a href="#按函数排序" class="headerlink" title="按函数排序"></a>按函数排序</h3><ol>
<li>查询员工名，并且按名字的长度降序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(last_name), last_name</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY LENGTH(last_name) DESC;</span><br></pre></td></tr></table></figure>

<h3 id="多个字段排序"><a href="#多个字段排序" class="headerlink" title="多个字段排序"></a>多个字段排序</h3><ol>
<li>查询员工信息，要求先按工资降序，再按employee_id升序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees ORDER BY salary DESC, employee_id ASC;</span><br></pre></td></tr></table></figure>

<h1 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h1><h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><h3 id="LENGTH-s"><a href="#LENGTH-s" class="headerlink" title="LENGTH(s)"></a>LENGTH(s)</h3><p>获取参数值的字节个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&#39;Tom&#39;);</span><br><span class="line"># utf8字符集下，一个汉字占3个字节，gbk中，一个汉字占2个字节</span><br><span class="line">SELECT LENGTH(&#39;张三丰hahaha&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="CONCAT-s1-s2-…-sn"><a href="#CONCAT-s1-s2-…-sn" class="headerlink" title="CONCAT(s1, s2,…, sn)"></a>CONCAT(s1, s2,…, sn)</h3><p>拼接字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里表示使用 _ 连接字段last_name和字段first_name</span><br><span class="line">SELECT CONCAT(last_name, &#39;_&#39;, first_name) 姓名 FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="UPPER-s"><a href="#UPPER-s" class="headerlink" title="UPPER(s)"></a>UPPER(s)</h3><p>将字符串转换为大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&#39;tomcat&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="LOWER-s"><a href="#LOWER-s" class="headerlink" title="LOWER(s)"></a>LOWER(s)</h3><p>将字符串转换为小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LOWER(&#39;tomCat&#39;);</span><br><span class="line"># 示例：将姓变大写，名变小写，然后拼接</span><br><span class="line">SELECT CONCAT(UPPER(last_name), LOWER(first_name)) 姓名 FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="SUBSTR-s-start-length-、SUBSTRING"><a href="#SUBSTR-s-start-length-、SUBSTRING" class="headerlink" title="SUBSTR(s, start, length)、SUBSTRING()"></a>SUBSTR(s, start, length)、SUBSTRING()</h3><p>SUBSTR(s, start, length)：从字符串s的start位置截取长度为length的子字符串</p>
<p>截取字符串(<strong>注意：索引从1开始</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从第7个字符开始截取（包括7）</span><br><span class="line">SELECT SUBSTR(&#39;日向雏田爱上了旋涡鸣人&#39;, 7) out_put;</span><br><span class="line"># SUBSTRING() 效果和SUBSTR()一致</span><br><span class="line">SELECT SUBSTRING(&#39;日向雏田爱上了旋涡鸣人&#39;, 7) out_put;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUBSTR(&#39;日向雏田爱上了旋涡鸣人&#39;, 1, 4) out_put;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来</span><br><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name, 1,1)), &#39;_&#39;, LOWER(SUBSTR(last_name, 2))) out_put FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="INSTR-s-s"><a href="#INSTR-s-s" class="headerlink" title="INSTR(s, s)"></a>INSTR(s, s)</h3><p>返回子串第一次出现的索引，如果找不到，返回0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&#39;日向雏田爱上了漩涡鸣人，漩涡鸣人爱上了雏田&#39;, &#39;漩涡鸣人&#39;) AS out_put;</span><br></pre></td></tr></table></figure>

<h3 id="TRIM-s"><a href="#TRIM-s" class="headerlink" title="TRIM(s)"></a>TRIM(s)</h3><p>LTRIM(s)：去掉字符串s<strong>开始处</strong>的空格</p>
<p>RTRIM(s)：去掉字符串s<strong>结尾处</strong>的空格</p>
<p>去掉字符串开始和结尾处的空格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(TRIM(&#39;       日向雏田      &#39;)) AS out_put;</span><br><span class="line"># 去除字符串前后指定的字符</span><br><span class="line">SELECT TRIM(&#39;a&#39; FROM &#39;aaaaa雏aa田aaaaaa&#39;);</span><br><span class="line"># aa会被当做一个整体</span><br><span class="line">SELECT TRIM(&#39;aa&#39; FROM &#39;aaaaa雏aa田aaaaaa&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="LPAD-s1-len-s2"><a href="#LPAD-s1-len-s2" class="headerlink" title="LPAD(s1, len, s2)"></a>LPAD(s1, len, s2)</h3><p>在字符串s1的<strong>开始处</strong>填充字符串s2， 使字符串长度达到len，如果长度小于原字符串长度，则只取前len个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&#39;日向雏田&#39;, 6, &#39;*&#39;) AS out_put; </span><br><span class="line"># result: **日向雏田</span><br><span class="line">SELECT LPAD(&#39;日向雏田&#39;, 2, &quot;*&quot;) AS out_put;</span><br><span class="line"># result: 日向</span><br></pre></td></tr></table></figure>

<h3 id="RPAD-s1-len-s2"><a href="#RPAD-s1-len-s2" class="headerlink" title="RPAD(s1, len, s2)"></a>RPAD(s1, len, s2)</h3><p>在字符串s1<strong>结尾处</strong>添加字符串s2，使字符串的长度达到len，如果长度小于原字符串，则只取前len个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT RPAD(&#39;日向雏田&#39;, 6, &#39;*&#39;) AS out_put;</span><br><span class="line"># result：日向雏田**</span><br><span class="line">SELECT RPAD(&#39;日向雏田&#39;, 2, &#39;*&#39;) AS out_put;</span><br><span class="line"># result：日向 </span><br></pre></td></tr></table></figure>

<h3 id="REPLACE-s-s1-s2"><a href="#REPLACE-s-s1-s2" class="headerlink" title="REPLACE(s, s1, s2)"></a>REPLACE(s, s1, s2)</h3><p>用字符串 s2 替代字符串 s 中的字符串s1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&#39;漩涡鸣人爱上了春野樱&#39;, &#39;春野樱&#39;, &#39;日向雏田&#39;) AS out_put;</span><br><span class="line"># result : 漩涡鸣人爱上了日向雏田</span><br></pre></td></tr></table></figure>

<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><h3 id="ROUND-x"><a href="#ROUND-x" class="headerlink" title="ROUND(x)"></a>ROUND(x)</h3><p>ROUND(x, d)：四舍五入，保留d位小数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(-1.55); --&gt; -2</span><br><span class="line">SELECT ROUND(1.567, 2); --&gt; 1.57</span><br></pre></td></tr></table></figure>

<h3 id="CEIL-x"><a href="#CEIL-x" class="headerlink" title="CEIL(x)"></a>CEIL(x)</h3><p>向上取整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CEIL(-1.02); 	--&gt; -1</span><br><span class="line">SELECT CEIL(1.02);	  --&gt; 2</span><br></pre></td></tr></table></figure>

<h3 id="FLOOR-x"><a href="#FLOOR-x" class="headerlink" title="FLOOR(x)"></a>FLOOR(x)</h3><p>向下取整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FLOOR(-1.58); 	--&gt; -2</span><br><span class="line">SELECT FLOOR(1.58); 	--&gt; 1</span><br></pre></td></tr></table></figure>

<h3 id="TRUNCATE-x-y"><a href="#TRUNCATE-x-y" class="headerlink" title="TRUNCATE(x, y)"></a>TRUNCATE(x, y)</h3><p>返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRUNCATE(1.567, 2); 		--&gt; 1.56</span><br></pre></td></tr></table></figure>

<h3 id="MOD-x-y"><a href="#MOD-x-y" class="headerlink" title="MOD(x, y)"></a>MOD(x, y)</h3><p>*<em>MOD(x, y)的结果会等于：x - x / b * b*</em></p>
<p>返回 x 除以 y 以后的余数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MOD(10, -3); 	--&gt; 1</span><br><span class="line"># 等价于</span><br><span class="line">SELECT 10%-3; 		--&gt; 1</span><br><span class="line"></span><br><span class="line"># 余数的符号取决于被除数的符号</span><br><span class="line">SELECT MOD(-10, 3);		--&gt; -1</span><br><span class="line">SELECT MOD(-10, -3);  	--&gt; -1</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><h3 id="NOW"><a href="#NOW" class="headerlink" title="NOW()"></a>NOW()</h3><p>返回当前系统时间(注：日期+时间)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW();  	--&gt; 2019-12-17 00:38:55</span><br></pre></td></tr></table></figure>

<h3 id="CURDATE"><a href="#CURDATE" class="headerlink" title="CURDATE()"></a>CURDATE()</h3><p>返回当前系统日期，不包含时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE(); 	--&gt; 2019-12-17</span><br></pre></td></tr></table></figure>

<h3 id="CURTIME"><a href="#CURTIME" class="headerlink" title="CURTIME()"></a>CURTIME()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURTIME();	--&gt; 00:41:45</span><br></pre></td></tr></table></figure>

<h3 id="YEAR-d"><a href="#YEAR-d" class="headerlink" title="YEAR(d)"></a>YEAR(d)</h3><p>返回年份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(NOW()); 	--&gt; 2019</span><br><span class="line">SELECT YEAR(&#39;1999-1-1&#39;); 	--&gt; 1999</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(hiredate) 入职时间 FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="MONTH-d"><a href="#MONTH-d" class="headerlink" title="MONTH(d)"></a>MONTH(d)</h3><p>返回日期 d 中的月份值，1到12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTH(NOW()); 	--&gt; 12</span><br></pre></td></tr></table></figure>

<h3 id="MONTHNAME-d"><a href="#MONTHNAME-d" class="headerlink" title="MONTHNAME(d)"></a>MONTHNAME(d)</h3><p>返回日期当中的月份的英文名称，如 September</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTHNAME(NOW()); 	--&gt; December</span><br></pre></td></tr></table></figure>

<h3 id="STR-TO-DATE-s-f"><a href="#STR-TO-DATE-s-f" class="headerlink" title="STR_TO_DATE(s, f)"></a>STR_TO_DATE(s, f)</h3><p>将字符通过制定的格式转换成日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&#39;1998-9-25&#39;, &#39;%Y-%c-%d&#39;) AS out_put; --&gt; 1998-09-25</span><br></pre></td></tr></table></figure>

<p>案例：查询入职时间为1992-4-3的员工信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE hiredate &#x3D; &#39;1992-4-3&#39;;</span><br><span class="line"># 或者</span><br><span class="line">SELECT * FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3 1992&#39;, &#39;%c-%d %Y&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="DATE-FORMAT-d-f"><a href="#DATE-FORMAT-d-f" class="headerlink" title="DATE_FORMAT(d, f)"></a>DATE_FORMAT(d, f)</h3><p>将日期通过指定的格式转换成字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(), &#39;%Y年%m月%d日&#39;) AS out_put；	--&gt; 2019年12月17日</span><br></pre></td></tr></table></figure>

<p>案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, DATE_FORMAT(hiredate, &#39;%m月&#x2F;%d日 %Y年&#39;) 入职日期</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br></pre></td></tr></table></figure>

<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION()"></a>VERSION()</h3><p>返回数据库的版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>

<h3 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE()"></a>DATABASE()</h3><p>返回当前数据库名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>

<h3 id="USER"><a href="#USER" class="headerlink" title="USER()"></a>USER()</h3><p>返回当前用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure>

<h3 id="PASSWORD-‘字符’"><a href="#PASSWORD-‘字符’" class="headerlink" title="PASSWORD(‘字符’)"></a>PASSWORD(‘字符’)</h3><p>返回该字符的密码形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT PASSWORD(&#39;雏田&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="MD5-‘字符’"><a href="#MD5-‘字符’" class="headerlink" title="MD5(‘字符’)"></a>MD5(‘字符’)</h3><p>返回该字符的md5加密形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MD5(&#39;雏田&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><h3 id="IF-expr-v1-v2"><a href="#IF-expr-v1-v2" class="headerlink" title="IF(expr, v1, v2)"></a>IF(expr, v1, v2)</h3><p>如果表达式 expr 成立，返回结果 v1， 否则返回结果 v2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(1 &gt; 0, &#39;正确&#39;, &#39;错误&#39;); 	--&gt; 正确</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, commission_pct, </span><br><span class="line">IF(commission_pct IS NULL, &#39;没奖金，日了狗了&#39;, &#39;有奖金，开心&#39;) 备注</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE expression</span><br><span class="line">	WHEN condition1 THEN result1</span><br><span class="line">	WHEN condition2 THEN result2</span><br><span class="line">	...</span><br><span class="line">	when conditionN	THEN resultN</span><br><span class="line">	ELSE result</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>CASE 表示函数开始，END 表示函数结束。如果condition1成立，则返回result1，如果condition2成立，则返回result2，当全部不成立则返回result，而当有一个成立之后，后面的就不执行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE 要判断的字段或表达式</span><br><span class="line">WHEN 常量1 THEN 要显示的值1或语句1</span><br><span class="line">WHEN 常量2 THEN 要现实的值2或语句2</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或者语句n</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>案例一：</p>
<p>查询员工的工资，要求：</p>
<ol>
<li>部门号=30，显示的工资为1.1倍</li>
<li>部门号=40，显示的工资为1.2倍</li>
<li>部门号=50，显示的工资为1.3倍</li>
<li>其他部门，显示的工资为原工资</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary 原工资, department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary * 1.1</span><br><span class="line">WHEN 40 THEN salary * 1.2</span><br><span class="line">WHEN 50 THEN salary * 1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>案例二：</p>
<p>查询员工的工资情况，要求：</p>
<ol>
<li>如果工资&gt;20000，显示A级别</li>
<li>如果工资&gt;15000，显示B级别</li>
<li>如果工资&gt;10000，显示C级别</li>
<li>否则，显示D级别</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary,</span><br><span class="line">CASE</span><br><span class="line">WHEN salary &gt; 20000 THEN &#39;A&#39;</span><br><span class="line">WHEN salary &gt; 15000 THEN &#39;B&#39;</span><br><span class="line">WHEN salary &gt; 10000 THEN &#39;C&#39;</span><br><span class="line">ELSE &#39;D&#39;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<h1 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h1><p>用作统计使用，又称为聚合函数或同级函数或组函数</p>
<h2 id="SUM-expression"><a href="#SUM-expression" class="headerlink" title="SUM(expression)"></a>SUM(expression)</h2><p>求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="AVG-expression"><a href="#AVG-expression" class="headerlink" title="AVG(expression)"></a>AVG(expression)</h2><p>求平均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary) FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="MAX-expression"><a href="#MAX-expression" class="headerlink" title="MAX(expression)"></a>MAX(expression)</h2><p>求最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary) FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="MIN-expression"><a href="#MIN-expression" class="headerlink" title="MIN(expression)"></a>MIN(expression)</h2><p>求最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary) FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="COUNT-expression"><a href="#COUNT-expression" class="headerlink" title="COUNT(expression)"></a>COUNT(expression)</h2><p>计算个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(1) FROM employees;</span><br></pre></td></tr></table></figure>

<p><strong>效率：MYISAM 存储引擎下，COUNT(<code>*</code>)的效率高；INNODB存储引擎下，COUNT(<code>*</code>)和COUNT(1)的效率差不多，比COUNT(字段)效率要高一些；</strong><br>​    <strong>推荐使用COUNT(<code>*</code>)统计行数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	SUM( salary ) 和,</span><br><span class="line">	AVG( salary ) 平均,</span><br><span class="line">	MAX( salary ) 最高,</span><br><span class="line">	MIN( salary ) 最低,</span><br><span class="line">	COUNT( salary ) 个数</span><br><span class="line">FROM</span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>

<p>平均工资保留两位小数（四舍五入）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	SUM( salary ) 和,</span><br><span class="line">	ROUND(AVG( salary ), 2) 平均,</span><br><span class="line">	MAX( salary ) 最高,</span><br><span class="line">	MIN( salary ) 最低,</span><br><span class="line">	COUNT( salary ) 个数</span><br><span class="line">FROM </span><br><span class="line">	employees;</span><br></pre></td></tr></table></figure>

<h2 id="支持哪些类型的参数"><a href="#支持哪些类型的参数" class="headerlink" title="支持哪些类型的参数"></a>支持哪些类型的参数</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>先试图将字符转换成数值，如果转换成功，则继续运算，否则转换成0，再做运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	SUM(last_name),</span><br><span class="line">	AVG(last_name)</span><br><span class="line">FROM</span><br><span class="line">	employees;</span><br><span class="line">#----------------------------</span><br><span class="line"># result: 0  0</span><br></pre></td></tr></table></figure>

<p>与排序差不多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	MAX( last_name ),</span><br><span class="line">	MIN( last_name )</span><br><span class="line">FROM </span><br><span class="line">	employees;</span><br><span class="line"># MAX(expr) 和 MIN(expr) 在对英文字符串比大小的时候，先比较首字母的大小（b &gt; a），如果首字母相同，则比较第二个字母的大小，以此类推</span><br></pre></td></tr></table></figure>

<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(hiredate), AVG(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(hiredate), MIN(hiredate) FROM employees;</span><br></pre></td></tr></table></figure>

<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol>
<li>SUM、AVG一般用于处理数值型</li>
<li>MAX、MIN、COUNT可以处理任何类型</li>
<li>以上分组函数都忽略NULL值</li>
<li>可以和DISTINCT搭配实现去重的运算</li>
<li>一般使用COUNT(*) 用作统计行数</li>
<li>和分组函数一同查询的字段要求是 GROUP BY后的字段</li>
</ol>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><ol>
<li>查询员工表中的最大入职时间和最小入职时间的相差天数（DIFFRENCE）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	MAX( hiredate ) 最大,</span><br><span class="line">	MIN( hiredate ) 最小,</span><br><span class="line">	(MAX( hiredate ) - MIN( hiredate )) &#x2F; 1000 &#x2F; 3600 &#x2F; 24 AS DIFFRENCE</span><br><span class="line">FROM </span><br><span class="line">	employees;</span><br><span class="line">	-- 错误写法</span><br></pre></td></tr></table></figure>

<p>​    使用DATEDIFF(d1, d2)函数，计算日期d1 ~ d2之间相隔的天数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATEDIFF(MAX(hiredate), MIN(hiredate)) AS DIFFRENCE FROM employees;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询部门编号为90的员工个数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	COUNT(*)</span><br><span class="line">FROM</span><br><span class="line">	employees</span><br><span class="line">WHERE</span><br><span class="line">	department_id &#x3D; 90;</span><br></pre></td></tr></table></figure>

<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 分组函数, 分组后的字段</span><br><span class="line">FROM 表</span><br><span class="line">[WHERE 筛选条件]</span><br><span class="line">GROUP BY 分组后的字段</span><br><span class="line">[HAVING 分组后的筛选]</span><br><span class="line">[ORDER BY 排序列表]</span><br></pre></td></tr></table></figure>

<h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ol>
<li>和分组函数一同查询的字段<strong>必须</strong>是GROUP BY后出现的字段</li>
<li>筛选分为两类：分组前筛选和分组后筛选</li>
</ol>
<table>
<thead>
<tr>
<th align="center">筛选</th>
<th align="center">针对的表</th>
<th align="center">连接的关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分组前筛选</td>
<td align="center">原始表</td>
<td align="center">WHERE</td>
</tr>
<tr>
<td align="center">分组后筛选</td>
<td align="center">GROUP BY后的结果集</td>
<td align="center">HAVING</td>
</tr>
</tbody></table>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>分组函数做筛选能不能放在WHERE后面</p>
<p>答案：不能，原表中没有分组后的数据</p>
</li>
</ol>
<h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><h3 id="简单的分组"><a href="#简单的分组" class="headerlink" title="简单的分组"></a>简单的分组</h3><ol>
<li>查询每个工种的员工平均工资</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary), job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询每个位置的部门个数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*), location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br></pre></td></tr></table></figure>

<h3 id="分组前筛选"><a href="#分组前筛选" class="headerlink" title="分组前筛选"></a>分组前筛选</h3><ol>
<li>查询邮箱中包含a字符的 每个部门的最高工资</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary), department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email LIKE &#39;%a%&#39;</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询有奖金的每个领导手下员工的平均工资</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary), manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br></pre></td></tr></table></figure>

<h3 id="分组后筛选"><a href="#分组后筛选" class="headerlink" title="分组后筛选"></a>分组后筛选</h3><ol>
<li><p>查询哪个部门的员工个数&gt;5</p>
<p>1.1 首先查询每个部门的员工个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*), department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure>

<p>1.2 筛选1.1得到的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*), department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING COUNT(*) &gt; 5;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary), job_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary) &gt; 12000;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT manager_id, MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id &gt; 102</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary) &gt; 5000;</span><br></pre></td></tr></table></figure>

<h3 id="添加排序"><a href="#添加排序" class="headerlink" title="添加排序"></a>添加排序</h3><ol>
<li>每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资，按最高工资升序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT job_id, MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary) &gt; 6000</span><br><span class="line">ORDER BY MAX(salary) ASC;</span><br></pre></td></tr></table></figure>

<h3 id="按多个字段分组"><a href="#按多个字段分组" class="headerlink" title="按多个字段分组"></a>按多个字段分组</h3><ol>
<li>查询每个工种每个部门的最低工资，并按最低工资降序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT job_id, department_id, MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id, department_id</span><br><span class="line">ORDER BY MIN(salary) DESC;</span><br></pre></td></tr></table></figure>

<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>连接查询又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段1, 字段2 FROM 表1, 表2,...；</span><br></pre></td></tr></table></figure>

<h2 id="笛卡尔乘积现象"><a href="#笛卡尔乘积现象" class="headerlink" title="笛卡尔乘积现象"></a>笛卡尔乘积现象</h2><p>当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接</p>
<p>表1 有m行，表2 有n行，结果 = m * n 行</p>
<p>发生原因：没有有效的连接条件</p>
<p>如何避免：添加有效的连接条件</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按年代分类：</p>
<ul>
<li>sql92标准：仅仅支持内连接</li>
<li>sql99标准【推荐】：支持内连接、外连接（左外连接和右外连接）、交叉连接</li>
</ul>
<p>按功能分类：</p>
<ul>
<li>内连接：<ol>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ol>
</li>
<li>外连接：<ol>
<li>左外连接</li>
<li>右外连接</li>
<li>全外连接（mysql不支持）</li>
</ol>
</li>
<li>交叉连接</li>
</ul>
<h2 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h2><ol>
<li>多表等值连接的结果为多表的交集部分</li>
<li>n表连接，至少需要n-1个连接条件</li>
<li>表的顺序没有要求</li>
<li>一般需要为表起别名</li>
<li>可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</li>
</ol>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><ol>
<li><p>查询女神名和对应的男神名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, boyName</span><br><span class="line">FROM boys, beauty</span><br><span class="line">WHERE beauty.boyfriend_id &#x3D; boys.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询员工名和对应的部门名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, department_name</span><br><span class="line">FROM employees, departments</span><br><span class="line">WHERE employees.department_id &#x3D; departments.department_id;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="为表起别名"><a href="#为表起别名" class="headerlink" title="为表起别名"></a>为表起别名</h3><ol>
<li>提高语句的简洁度</li>
<li>区分多个重名的字段</li>
</ol>
<p><strong>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</strong></p>
<ol>
<li><p>查询员工名、工种号、工种名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	e.last_name, </span><br><span class="line">	e.job_id, </span><br><span class="line">	j.job_title</span><br><span class="line">FROM </span><br><span class="line">	employees AS e, </span><br><span class="line">	jobs AS j</span><br><span class="line">WHERE </span><br><span class="line">	e.job_id &#x3D; j.job_id;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="加筛选条件"><a href="#加筛选条件" class="headerlink" title="加筛选条件"></a>加筛选条件</h3><ol>
<li><p>查询有奖金的员工名、部门名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	e.last_name, </span><br><span class="line">	d.department_name, </span><br><span class="line">	e.commission_pct</span><br><span class="line">FROM </span><br><span class="line">	employees e, </span><br><span class="line">	departments d</span><br><span class="line">WHERE </span><br><span class="line">	e.department_id &#x3D; d.department_id  </span><br><span class="line">	AND e.commission_pct IS NOT NULL; </span><br></pre></td></tr></table></figure>
</li>
<li><p>查询城市名中第二个字符为o的部门名和城市名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	department_name, </span><br><span class="line">	city</span><br><span class="line">FROM </span><br><span class="line">	departments d, </span><br><span class="line">	locations l</span><br><span class="line">WHERE </span><br><span class="line">	d.location_id &#x3D; l.location_id AND city LIKE &#39;_o%&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="加分组"><a href="#加分组" class="headerlink" title="加分组"></a>加分组</h3><ol>
<li><p>查询每个城市的部门个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	COUNT(*) 部门个数,</span><br><span class="line">	city</span><br><span class="line">FROM </span><br><span class="line">	departments d, locations l</span><br><span class="line">WHERE </span><br><span class="line">	d.location_id &#x3D; l.location_id</span><br><span class="line">GROUP BY </span><br><span class="line">	city;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询有奖金的每个部门的部门名和部门领导编号和该部门的最低工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	department_name, </span><br><span class="line">	d.manager_id, </span><br><span class="line">	MIN(salary)</span><br><span class="line">FROM </span><br><span class="line">	employees e,</span><br><span class="line">	departments d</span><br><span class="line">WHERE </span><br><span class="line">	d.department_id &#x3D; e.department_id AND commission_pct IS NOT NULL</span><br><span class="line">GROUP BY </span><br><span class="line">	department_name, d.manager_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个工种的工种名和员工的个数，并且按员工个数降序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	job_title,</span><br><span class="line">	COUNT(*)</span><br><span class="line">FROM </span><br><span class="line">	employees e,</span><br><span class="line">	jobs j</span><br><span class="line">WHERE</span><br><span class="line">	e.job_id &#x3D; j.job_id</span><br><span class="line">GROUP BY</span><br><span class="line">	job_title</span><br><span class="line">ORDER BY </span><br><span class="line">	COUNT(*) DESC;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询员工名、部门名和所在的城市，并且城市名以s开头，按部门名称降序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	e.last_name 员工名,</span><br><span class="line">	d.department_name 部门名,</span><br><span class="line">	l.city 城市</span><br><span class="line">FROM </span><br><span class="line">	employees e,</span><br><span class="line">	departments d,</span><br><span class="line">	locations l</span><br><span class="line">WHERE</span><br><span class="line">	e.department_id &#x3D; d.department_id AND d.location_id &#x3D; l.location_id AND city LIKE &#39;s%&#39;</span><br><span class="line">ORDER BY</span><br><span class="line">	department_name DESC;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表1 别名, 表2 别名</span><br><span class="line">WHERE 非等值的连接条件</span><br><span class="line">[and 筛选条件]</span><br><span class="line">[GROUP BY 分组字段]</span><br><span class="line">[HAVING 分组后的筛选]</span><br><span class="line">[ORDER BY 排序字段]</span><br></pre></td></tr></table></figure>

<h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><ol>
<li><p>查询员工的工资和工资级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	e.salary 工资,</span><br><span class="line">	j.grade_level 工资级别</span><br><span class="line">FROM</span><br><span class="line">	employees e,</span><br><span class="line">	job_grades j</span><br><span class="line">WHERE </span><br><span class="line">	e.salary BETWEEN j.lowest_sal AND j.highest_sal;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询员工的工资和工资级别并筛选出级别为A的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	e.salary 工资,</span><br><span class="line">	j.grade_level 工资级别</span><br><span class="line">FROM</span><br><span class="line">	employees e,</span><br><span class="line">	job_grades j</span><br><span class="line">WHERE</span><br><span class="line">	e.salary BETWEEN j.lowest_sal AND j.highest_sal AND j.grade_level &#x3D; &#39;A&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表 别名1, 表 别名2</span><br><span class="line">WHERE 等值的连接条件</span><br><span class="line">[and 筛选条件]</span><br><span class="line">[GROUP BY 分组字段]</span><br><span class="line">[HAVING 分组后的筛选]</span><br><span class="line">[ORDER BY 排序字段]</span><br></pre></td></tr></table></figure>

<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><ol>
<li><p>查询员工名和上级的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	e.last_name 员工名,</span><br><span class="line">	m.last_name 上级名称</span><br><span class="line">FROM </span><br><span class="line">	employees e,</span><br><span class="line">	employees m</span><br><span class="line">WHERE</span><br><span class="line">	e.manager_id &#x3D; m.employee_id;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SQL99语法-内连接"><a href="#SQL99语法-内连接" class="headerlink" title="SQL99语法-内连接"></a>SQL99语法-内连接</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表1 别名</span><br><span class="line">[INNER] JOIN 表2 别名 ON 连接条件</span><br><span class="line">WHERE 筛选条件</span><br><span class="line">GROUP BY 分组列表</span><br><span class="line">HAVING 分组后的筛选</span><br><span class="line">ORDER BY 排序列表</span><br><span class="line">LIMIT 子句;</span><br></pre></td></tr></table></figure>

<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ol>
<li>表的顺序可以调换</li>
<li>内连接的结果 = 多表的交集</li>
<li>n表连接至少需要 n - 1 个连接条件</li>
<li>添加排序、分组、筛选</li>
<li>INNER 可以省略</li>
<li>筛选条件放在WHERE后面，连接条件放在ON后面，提高分离性，便于阅读</li>
<li>INNER JOIN连接和SQL92语法中的等值连接效果是一样的，都是查询多表的交集</li>
</ol>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
<h3 id="内连接-等值连接案例"><a href="#内连接-等值连接案例" class="headerlink" title="内连接-等值连接案例"></a>内连接-等值连接案例</h3><ol>
<li><p>查询员工名、部门名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	last_name,</span><br><span class="line">	department_name </span><br><span class="line">FROM</span><br><span class="line">	employees e</span><br><span class="line">	INNER JOIN departments d ON e.department_id &#x3D; d.department_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询名字中包含e的员工名和工种名(添加筛选)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	last_name,</span><br><span class="line">	job_title</span><br><span class="line">FROM employees e</span><br><span class="line">	JOIN jobs j ON e.job_id &#x3D; j.job_id</span><br><span class="line">WHERE</span><br><span class="line">	e.last_name LIKE &#39;%e%&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询部门个数&gt;3的城市名和部门个数（添加分组+筛选）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	city 城市名,</span><br><span class="line">	COUNT(department_id) 部门个数</span><br><span class="line">FROM </span><br><span class="line">	locations l</span><br><span class="line">	JOIN departments d ON l.location_id &#x3D; d.location_id</span><br><span class="line">GROUP BY</span><br><span class="line">	l.city</span><br><span class="line">HAVING</span><br><span class="line">	COUNT(department_id) &gt; 3;</span><br><span class="line"># 这里的 COUNT(department_id) 换成 COUNT(*)效果一致</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序 ( 添加排序 )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	d.department_name 部门名,</span><br><span class="line">	count( * ) 员工个数 </span><br><span class="line">FROM</span><br><span class="line">	employees e</span><br><span class="line">	JOIN departments d ON e.department_id &#x3D; d.department_id </span><br><span class="line">GROUP BY</span><br><span class="line">	d.department_name </span><br><span class="line">HAVING</span><br><span class="line">	count( * ) &gt; 3 </span><br><span class="line">ORDER BY</span><br><span class="line">	count( * ) DESC;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询员工、部门名、工种名、并按部门名降序（添加三表连接）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	e.last_name 员工名,</span><br><span class="line">	d.department_name 部门名,</span><br><span class="line">	j.job_title 工种名</span><br><span class="line">FROM</span><br><span class="line">	employees e</span><br><span class="line">	JOIN departments d ON e.department_id &#x3D; d.department_id</span><br><span class="line">	JOIN jobs j ON e.job_id &#x3D; j.job_id</span><br><span class="line">ORDER BY</span><br><span class="line">	d.department_name DESC;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="内连接-非等值连接案例"><a href="#内连接-非等值连接案例" class="headerlink" title="内连接-非等值连接案例"></a>内连接-非等值连接案例</h3><ol>
<li><p>查询员工的工资级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	e.last_name 员工名,</span><br><span class="line">	e.salary 薪水,</span><br><span class="line">	j.grade_level 工资级别</span><br><span class="line">FROM</span><br><span class="line">	employees e</span><br><span class="line">	JOIN job_grades j ON e.salary BETWEEN j.lowest_sal AND j.highest_sal;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询工资级别的个数&gt;20的个数，并且按工资级别降序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	j.grade_level 工资级别,</span><br><span class="line">	COUNT(*) 个数</span><br><span class="line">FROM</span><br><span class="line">	employees e</span><br><span class="line">	JOIN job_grades j ON e.salary BETWEEN j.lowest_sal AND j.highest_sal</span><br><span class="line">GROUP BY</span><br><span class="line">	j.grade_level</span><br><span class="line">HAVING</span><br><span class="line">	COUNT(*) &gt; 20</span><br><span class="line">ORDER BY </span><br><span class="line">	j.grade_level DESC;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="内连接-自连接案例"><a href="#内连接-自连接案例" class="headerlink" title="内连接-自连接案例"></a>内连接-自连接案例</h3><ol>
<li><p>查询员工的名字、上级的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	e.last_name 员工名,</span><br><span class="line">	m.last_name 上级名</span><br><span class="line">FROM</span><br><span class="line">	employees e</span><br><span class="line">	JOIN employees m ON e.manager_id &#x3D; m.employee_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询姓名中包含字符k的员工的名字、上级的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	e.last_name 员工名,</span><br><span class="line">	m.last_name 上级名</span><br><span class="line">FROM</span><br><span class="line">	employees e</span><br><span class="line">	JOIN employees m ON e.manager_id &#x3D; m.employee_id</span><br><span class="line">WHERE</span><br><span class="line">	e.last_name LIKE &#39;%k%&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SQL99语法-外连接"><a href="#SQL99语法-外连接" class="headerlink" title="SQL99语法-外连接"></a>SQL99语法-外连接</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表1 别名</span><br><span class="line">LEFT|RIGHT|FULL[OUTER] JOIN 表2 别名 ON 连接条件</span><br><span class="line">WHERE 筛选条件</span><br><span class="line">GROUP BY 分组列表</span><br><span class="line">HAVING 分组后的筛选</span><br><span class="line">ORDER BY 排序列表</span><br><span class="line">LIMIT 子句;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>应用于查询一个表中有，另一个表中没有的记录</p>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的，则显示匹配的值；如果从表中没有和它匹配的，则显示null；</p>
<p>外连接查询结果 = 内连接结果 + 主表中有而从表没有的记录</p>
</li>
<li><p>左外连接，LEFT JOIN 左边的表是主表</p>
</li>
<li><p>右外连接，RIGHT JOIN 右边的表是主表</p>
</li>
<li><p>左外和右外交换两个表的顺序，可以实现同样的效果</p>
</li>
<li><p>全外连接 = 内连接的结果 + 表1中有但表2中没有的 + 表2中有但表1中没有的</p>
</li>
</ol>
<h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><ol>
<li><p>查询哪个部门没有员工</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	d.*</span><br><span class="line">FROM</span><br><span class="line">	departments d</span><br><span class="line">	LEFT JOIN employees e ON d.department_id &#x3D; e.department_id</span><br><span class="line">WHERE</span><br><span class="line">	e.department_id IS NULL;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><ol>
<li><p>查询哪个部门没有员工（调换位置使用RIGHT JOIN）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	d.*</span><br><span class="line">FROM </span><br><span class="line">	employees e</span><br><span class="line">	RIGHT JOIN departments d ON d.department_id &#x3D; e.department_id</span><br><span class="line">WHERE </span><br><span class="line">	e.department_id IS NULL;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h3><p><strong>mysql不支持全外连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE girls;</span><br><span class="line">SELECT b.*,bo.*</span><br><span class="line">FROM beauty b</span><br><span class="line">FULL OUTER JOIN boys bo</span><br><span class="line">ON b.&#96;boyfriend_id&#96; &#x3D; bo.id;</span><br></pre></td></tr></table></figure>

<p>beauty表中有其他的数据与boys表没有关系(就是这些女神还是单身)，就把boys表的那部分全部显示为空，</p>
<p>同样boys表有的beauty没有的也是显示null</p>
<h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>交叉连接返回左边中的所有行，坐标中的每一行与右表中的所有行组合。<strong>交叉连接也称作笛卡尔积</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT b.*, bo.*</span><br><span class="line">FROM beauty b</span><br><span class="line">CROSS JOIN boys bo;</span><br></pre></td></tr></table></figure>

<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h2 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h2><p>嵌套在其他语句内部的SELECT语句称为子查询或内查询，外面的语句可以是INSERT、UPDATE、DELETE、SELECT等，一般SELECT作为外面语句较多，外面如果为SELECT语句，则次语句称为外查询或主查询</p>
<h2 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h2><h3 id="按出现位置"><a href="#按出现位置" class="headerlink" title="按出现位置"></a>按出现位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 后面：</span><br><span class="line">		仅仅支持标量子查询</span><br><span class="line">FROM 后面：</span><br><span class="line">		表子查询</span><br><span class="line">WHERE 或 HAVING后面：</span><br><span class="line">		标量子查询</span><br><span class="line">		列子查询</span><br><span class="line">		行子查询</span><br><span class="line">EXISTS 后面：</span><br><span class="line">		标量子查询</span><br><span class="line">		列子查询</span><br><span class="line">		行子查询</span><br><span class="line">		表子查询</span><br></pre></td></tr></table></figure>

<h3 id="按结果集的行列"><a href="#按结果集的行列" class="headerlink" title="按结果集的行列"></a>按结果集的行列</h3><p>标量子查询（单行子查询）：结果集为一行一列</p>
<p>列子查询（多行子查询）：结果集为多行一列</p>
<p>行子查询：结果集为多行多列</p>
<p>表子查询：结果集为多行多列</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="WHERE或HAVING后面"><a href="#WHERE或HAVING后面" class="headerlink" title="WHERE或HAVING后面"></a>WHERE或HAVING后面</h3><ol>
<li>标量子查询（单行单列）</li>
<li>列子查询（多行单列）</li>
<li>行子查询（多行多列）</li>
</ol>
<h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ol>
<li>子查询放在小括号内</li>
<li>子查询一般放在条件的右侧</li>
<li>标量子查询，一般搭配着单行操作符（&lt;、&gt;、&lt;=、&gt;=、=、&lt;&gt;）使用</li>
<li>列子查询，一般搭配着多行操作符（IN、ANY/SOME、ALL）使用</li>
<li>子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</li>
</ol>
<h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><ol>
<li><p>谁的工资比Abel搞？</p>
<p>① 先查询Abel的工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name &#x3D; &#39;Abel&#39;;</span><br></pre></td></tr></table></figure>

<p>② 查询员工的信息，满足salary &gt; ①的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name &#x3D; &#39;Abel&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</p>
<p>① 查询141号员工的job_id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT job_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id &#x3D; 141;</span><br></pre></td></tr></table></figure>

<p>② 查询143号员工的salary</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id &#x3D; 143;</span><br></pre></td></tr></table></figure>

<p>③ 查询员工的姓名，job_id和工资，要求job_id=①并且salary &gt; ②</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; (</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id &#x3D; 141</span><br><span class="line">) AND salary &gt; (</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id &#x3D; 143</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回公司工资最少的员工的last_name, job_id和salary</p>
<p>① 查询公司的最低工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>② 查询last_name, job_id，要求salary = ①</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &#x3D; (</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询最低工资大于50号部门最低工资的部门的id和其最低工资</p>
<p>① 查询50号部门的最低工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &#x3D; 50;</span><br></pre></td></tr></table></figure>

<p>② 查询每个部门的最低工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary), department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></table></figure>

<p>③ 在②的基础上，筛选MIN(salary) &gt; ①</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary), department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary) &gt; (</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE department_id &#x3D; 50</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>非法使用标量子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary),department_id </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">HAVING MIN(salary)&gt;(     </span><br><span class="line">    SELECT  salary     </span><br><span class="line">    FROM employees     </span><br><span class="line">    WHERE department_id &#x3D; 250 </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里250号部门不存在，是查不出结果的，没有结果就不是标量子查询(结果不是一行一列)，所以这样非法的，会报错</p>
</li>
</ol>
<h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IN|NOT IN</td>
<td align="center">等于或不等于列表中的任意一个</td>
</tr>
<tr>
<td align="center">ANY|SOME</td>
<td align="center">和子查询返回的某一个值比较</td>
</tr>
<tr>
<td align="center">ALL</td>
<td align="center">和子查询返回的所有值比较</td>
</tr>
</tbody></table>
<ol>
<li><p>返回location_id是1400或1700的部门中的所有员工</p>
<p>① 查询location_id是1400或1700的部门标号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments</span><br><span class="line">WHERE location_id IN(1400, 1700);</span><br></pre></td></tr></table></figure>

<p>② 查询员工姓名，要求部门号是①列表中的某一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">    FROM departments</span><br><span class="line">    WHERE location_id IN(1400, 1700)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回其它工种中比job_id为“IT_PROG”工种任一工资低的员工的员工号、姓名、job_id以及salary</p>
<p>① 查询job_id为“IT_PROG”部门任一工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure>

<p>② 查询员工号、姓名、job_id、以及salary，salary&lt;(①)的任意一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, employee_id, job_id, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ANY(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) AND job_id &lt;&gt; &#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure>

<p>或者(小于最大值，就肯定满足任意一个)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">    SELECT MAX(salary)</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回其它工种中比job_id为‘IT_PROG’工种所有工资都低的员工 的员工号、姓名、job_id 以及salary</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ALL(</span><br><span class="line">    SELECT DISTINCT salary</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure>

<p>或者（小于最小的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">    SELECT MIN( salary)</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><ol>
<li><p>查询员工编号最小并且工资最高的员工信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM employees</span><br><span class="line">WHERE (employee_id,salary)&#x3D;(</span><br><span class="line">    SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">    FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id&#x3D;(</span><br><span class="line">    SELECT MIN(employee_id)</span><br><span class="line">    FROM employees</span><br><span class="line">)AND salary&#x3D;(</span><br><span class="line">    SELECT MAX(salary)</span><br><span class="line">    FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="SELECT后面"><a href="#SELECT后面" class="headerlink" title="SELECT后面"></a>SELECT后面</h3><p>仅仅支持标量子查询</p>
<ol>
<li><p>查询每个部门的员工个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT d.*,(</span><br><span class="line">    SELECT COUNT(*)</span><br><span class="line">    FROM employees e</span><br><span class="line">    WHERE e.department_id &#x3D; d.&#96;department_id&#96;</span><br><span class="line"> ) 个数</span><br><span class="line"> FROM departments d;</span><br></pre></td></tr></table></figure>

<p>或者（使用外连接）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    d.*,</span><br><span class="line">    count( e.employee_id ) 个数 </span><br><span class="line">FROM</span><br><span class="line">    employees e</span><br><span class="line">    RIGHT JOIN departments d ON e.department_id &#x3D; d.department_id </span><br><span class="line">GROUP BY</span><br><span class="line">    d.department_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询员工号=102的部门名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT department_id,( </span><br><span class="line">    SELECT department_name </span><br><span class="line">    FROM departments d </span><br><span class="line">    WHERE department_id &#x3D; e.department_id </span><br><span class="line">) </span><br><span class="line">FROM</span><br><span class="line">    employees e </span><br><span class="line">WHERE</span><br><span class="line">    e.employee_id &#x3D; 102;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT department_name,e.department_id</span><br><span class="line">    FROM departments d</span><br><span class="line">    INNER JOIN employees e</span><br><span class="line">    ON d.department_id&#x3D;e.department_id</span><br><span class="line">    WHERE e.employee_id&#x3D;102;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="FROM后面"><a href="#FROM后面" class="headerlink" title="FROM后面"></a>FROM后面</h3><p>将子查询结果充当一张表，要求必须起别名</p>
<ol>
<li><p>查询每个部门的平均工资的工资等级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  ag_dep.*,g.&#96;grade_level&#96;</span><br><span class="line">FROM (</span><br><span class="line">    SELECT AVG(salary) ag,department_id</span><br><span class="line">    FROM employees</span><br><span class="line">    GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line">INNER JOIN job_grades g</span><br><span class="line">ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="EXISTS后面-相关子查询"><a href="#EXISTS后面-相关子查询" class="headerlink" title="EXISTS后面(相关子查询)"></a>EXISTS后面(相关子查询)</h3><p>判断子查询是否存在结果，存在返回1，不存在返回0，可用于筛选判断</p>
<ol>
<li><p>查询有员工的部门名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM employees e</span><br><span class="line">    WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询没有女朋友的男神信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">    SELECT boyfriend_id</span><br><span class="line">    FROM beauty b</span><br><span class="line">    WHERE bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE bo.id NOT IN(</span><br><span class="line">    SELECT boyfriend_id</span><br><span class="line">    FROM beauty</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>能用EXISTS的地方就都能用IN替代</p>
</li>
</ol>
<h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>当要显示的数据，一页显示不全，需要分页提交sql请求</p>
<h2 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">    from 表</span><br><span class="line">    【join type】 join 表2</span><br><span class="line">    on 连接条件</span><br><span class="line">    where 筛选条件</span><br><span class="line">    group by 分组字段</span><br><span class="line">    having 分组后的筛选</span><br><span class="line">    order by 排序的字段】</span><br><span class="line">    limit 【offset,】size;</span><br></pre></td></tr></table></figure>

<p>offset 要显示条目的起始索引（起始索引从0开始）<br>​    size 要显示的条目个数</p>
<h2 id="分页公式"><a href="#分页公式" class="headerlink" title="分页公式"></a>分页公式</h2><p>(page - 1) * size, size</p>
<h2 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h2><ol>
<li><p>查询前五条员工信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees LIMIT 0, 5;</span><br><span class="line"># 或者</span><br><span class="line">SELECT * FROM employees LIMIT 5；</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询第11条~第25条员工信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees LIMIT 10, 15;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有奖金的员工信息，并且工资较高的前10名显示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    * </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h1><p>合并、联合，将多次查询结果合并成一个结果</p>
<h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union 【all】</span><br><span class="line">查询语句2</span><br><span class="line">union 【all】</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><ol>
<li>将一条比较复杂的查询语句拆分成多条语句</li>
<li>适用于查询多个表的时候，查询的列基本是一致</li>
</ol>
<h2 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h2><ol>
<li>要求多条查询语句的查询列数是一致的！</li>
<li>要求多条查询语句的查询的每一列的类型和顺序最好一致</li>
<li>UNION关键字默认去重，如果使用UNION ALL可以包含重复项</li>
</ol>
<h2 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h2><ol>
<li><p>查询部门编号&gt;90或邮箱包含a的员工信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt;90;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM employees  WHERE email LIKE &#39;%a%&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees  WHERE department_id&gt;90;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="DML-数据操纵语言"><a href="#DML-数据操纵语言" class="headerlink" title="DML(数据操纵语言)"></a>DML(数据操纵语言)</h1><p>DML(Data Manipulation Language - 数据操纵语言) 可以在下列条件下执行：</p>
<ul>
<li>向表中插入数据</li>
<li>修改现存数据</li>
<li>删除现存数据</li>
</ul>
<p><strong>事务是由完成若干项工作的DML语句组成的</strong></p>
<p>运行以下脚本创建表my_employees</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line">CREATE TABLE my_employees(</span><br><span class="line">    Id INT(10),</span><br><span class="line">    First_name VARCHAR(10),</span><br><span class="line">    Last_name VARCHAR(10),</span><br><span class="line">    Userid VARCHAR(10),</span><br><span class="line">    Salary DOUBLE(10,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE users(</span><br><span class="line">    id INT,</span><br><span class="line">    userid VARCHAR(10),</span><br><span class="line">    department_id INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>显示表my_employees的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC my_employees;</span><br></pre></td></tr></table></figure>

<h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名(字段名,...) values(值,...);</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ol>
<li><p>要求值的类型和字段的类型要一致或兼容</p>
</li>
<li><p>字段的个数和顺序不一定与原始表中的字段个数和顺序一致</p>
<p><strong>但必须保证值和字段一一对应</strong></p>
</li>
<li><p>假如表中有可以为null的字段，注意可以通过以下两种方式插入null值</p>
<p>① 字段和值都省略</p>
<p>② 字段写上，值使用null</p>
</li>
<li><p>字段和值的个数必须一致</p>
</li>
<li><p>字段名可以省略，默认所有列</p>
</li>
</ol>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名 set 字段&#x3D;值,字段&#x3D;值,...;</span><br></pre></td></tr></table></figure>

<p><strong>两种方式的区别：</strong></p>
<ol>
<li><p>方式一支持一次插入多行，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名【(字段名,..)】 values(值，..),(值，...),...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式一支持子查询，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="向表中插入数据"><a href="#向表中插入数据" class="headerlink" title="向表中插入数据"></a>向表中插入数据</h3><p>向my_employees表中插入下列数据</p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">FIRST_NAME</th>
<th align="center">LAST_NAME</th>
<th align="center">USERID</th>
<th align="center">SALARY</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">patel</td>
<td align="center">Ralph</td>
<td align="center">Rpatel</td>
<td align="center">895</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Dancs</td>
<td align="center">Betty</td>
<td align="center">Bdancs</td>
<td align="center">860</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Biri</td>
<td align="center">Ben</td>
<td align="center">Bbiri</td>
<td align="center">1100</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Newman</td>
<td align="center">Chad</td>
<td align="center">Cnewman</td>
<td align="center">750</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Ropeburn</td>
<td align="center">Audrey</td>
<td align="center">Aropebur</td>
<td align="center">155</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO my_employees</span><br><span class="line">VALUES</span><br><span class="line">    ( 1, &#39;patel&#39;, &#39;Ralph&#39;, &#39;Rpatel&#39;, 895 ),</span><br><span class="line">    ( 2, &#39;Dancs&#39;, &#39;Betty&#39;, &#39;Bdancs&#39;, 860 ),</span><br><span class="line">    ( 3, &#39;Biri&#39;, &#39;Ben&#39;, &#39;Bbiri&#39;, 1100 ),</span><br><span class="line">    ( 4, &#39;Newman&#39;, &#39;Chad&#39;, &#39;Cnewman&#39;, 750 ),</span><br><span class="line">    ( 5, &#39;Ropeburn&#39;, &#39;Audrey&#39;, &#39;Aropebur&#39;, 1550 );</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先删除表数据</span><br><span class="line">DELETE FROM my_employees;</span><br><span class="line"># 再插入</span><br><span class="line">INSERT INTO my_employees</span><br><span class="line">SELECT 1,&#39;patel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,895 UNION</span><br><span class="line">SELECT 2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bdancs&#39;,860 UNION</span><br><span class="line">SELECT 3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100 UNION</span><br><span class="line">SELECT 4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750 UNION</span><br><span class="line">SELECT 5,&#39;Ropeburn&#39;,&#39;Audrey&#39;,&#39;Aropebur&#39;,1550;</span><br></pre></td></tr></table></figure>

<p>向users表中插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO users</span><br><span class="line">VALUES</span><br><span class="line">    ( 1, &#39;Rpatel&#39;, 10 ),</span><br><span class="line">    ( 2, &#39;Bdancs&#39;, 10 ),</span><br><span class="line">    ( 3, &#39;Bbiri&#39;, 20 );</span><br></pre></td></tr></table></figure>

<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><h3 id="修改单表的记录"><a href="#修改单表的记录" class="headerlink" title="修改单表的记录"></a>修改单表的记录</h3><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段&#x3D;值,字段&#x3D;值 【where 筛选条件】;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将3号员工的last_name修改为“drelxer”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE my_employees SET last_name&#x3D;&#39;drelxer&#39; WHERE id &#x3D; 3;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有工资少于900的员工的工资修改为1000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE my_employees SET salary&#x3D;1000 WHERE salary&lt;900;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="修改多表的记录"><a href="#修改多表的记录" class="headerlink" title="修改多表的记录"></a>修改多表的记录</h3><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表1 别名 </span><br><span class="line">left|right|inner join 表2 别名 </span><br><span class="line">on 连接条件  </span><br><span class="line">set 字段&#x3D;值,字段&#x3D;值 </span><br><span class="line">【where 筛选条件】;</span><br></pre></td></tr></table></figure>

<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><h3 id="删除单表的记录"><a href="#删除单表的记录" class="headerlink" title="删除单表的记录"></a>删除单表的记录</h3><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 【where 筛选条件】【limit 条目数】</span><br></pre></td></tr></table></figure>

<h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete 别名1,别名2 from 表1 别名 </span><br><span class="line">inner|left|right join 表2 别名 </span><br><span class="line">on 连接条件</span><br><span class="line"> 【where 筛选条件】</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将userid 为Bbiri的user表和my_employees表的记录全部删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE u,e </span><br><span class="line">FROM</span><br><span class="line">    users u</span><br><span class="line">    JOIN my_employees e </span><br><span class="line">ON u.&#96;userid&#96; &#x3D; e.&#96;Userid&#96; </span><br><span class="line">WHERE</span><br><span class="line">    u.&#96;userid&#96; &#x3D; &#39;Bbiri&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM my_employees;</span><br><span class="line">DELETE FROM users;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h2><p>清空表</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<h2 id="DELETE和TRUNCATE的区别"><a href="#DELETE和TRUNCATE的区别" class="headerlink" title="DELETE和TRUNCATE的区别"></a>DELETE和TRUNCATE的区别</h2><ol>
<li>TRUNCATE删除后，如果再插入，标识列从1开始。DELETE删除后，如果再插入，标识列从断点开始</li>
<li>DELETE可以添加筛选条件，TRUNCATE不可以添加筛选条件</li>
<li>TRUNCATE效率较高</li>
<li>TRUNCATE没有返回值，DELETE可以返回受影响的行数</li>
<li>TRUNCATE不可以回滚，DELETE可以回滚</li>
</ol>
<h1 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL(数据定义语言)"></a>DDL(数据定义语言)</h1><p>DDL(Data Definition Language)：数据定义语言，用来定义数据库对象（数据库、表、列等）。</p>
<p><strong>关键字：CREATE、ALTER、DROP等</strong></p>
<ul>
<li>CREATE：创建</li>
<li>ALTER：修改</li>
<li>DROP：删除</li>
</ul>
<h2 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h2><h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database 【if not exists】 库名【 character set 字符集名】;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS books;</span><br></pre></td></tr></table></figure>

<h3 id="修改库"><a href="#修改库" class="headerlink" title="修改库"></a>修改库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database 库名 character set 字符集名;</span><br></pre></td></tr></table></figure>

<h3 id="修改库名"><a href="#修改库名" class="headerlink" title="修改库名"></a>修改库名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME DATABASE books TO 新库名;</span><br></pre></td></tr></table></figure>

<h3 id="修改库的字符集"><a href="#修改库的字符集" class="headerlink" title="修改库的字符集"></a>修改库的字符集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE books CHARACTER SET gbk;</span><br></pre></td></tr></table></figure>

<h3 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database 【if exists】 库名;</span><br></pre></td></tr></table></figure>

<h2 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h2><h3 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">    列名 列的类型【(长度) 约束】,</span><br><span class="line">    列名 列的类型【(长度) 约束】,</span><br><span class="line">    列名 列的类型【(长度) 约束】,</span><br><span class="line">    ...</span><br><span class="line">    列名 列的类型【(长度) 约束】</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>创建表 book表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE book ( </span><br><span class="line">    id INT, #编号</span><br><span class="line">    bName VARCHAR ( 20 ), #图书名</span><br><span class="line">    price DOUBLE, #价格</span><br><span class="line">    authorId INT, #作者编号</span><br><span class="line">    publishDate DATETIME #出版日期</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查看book表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC book;</span><br></pre></td></tr></table></figure>

<p>创建表 author</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS author(</span><br><span class="line">    id INT,</span><br><span class="line">    au_name VARCHAR(20),</span><br><span class="line">    nation VARCHAR(10)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add column 列名 类型 【first|after 字段名】;</span><br></pre></td></tr></table></figure>

<h4 id="修改列的类型或约束"><a href="#修改列的类型或约束" class="headerlink" title="修改列的类型或约束"></a>修改列的类型或约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 列名 新类型 【新约束】;</span><br></pre></td></tr></table></figure>

<h4 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 change column 旧列名 新列名 类型;</span><br></pre></td></tr></table></figure>

<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop column 列名;</span><br></pre></td></tr></table></figure>

<h4 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 rename 【to】 新表名;</span><br></pre></td></tr></table></figure>

<h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table【if exists】 表名;</span><br></pre></td></tr></table></figure>

<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><h4 id="复制表的结构"><a href="#复制表的结构" class="headerlink" title="复制表的结构"></a>复制表的结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名 like 旧表;</span><br></pre></td></tr></table></figure>

<h4 id="复制表的结构-数据"><a href="#复制表的结构-数据" class="headerlink" title="复制表的结构+数据"></a>复制表的结构+数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名 </span><br><span class="line">select 查询列表 from 旧表【where 筛选】;</span><br></pre></td></tr></table></figure>

<h4 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h4><ol>
<li><p>向author表插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO author</span><br><span class="line">VALUES</span><br><span class="line">    ( 1, &#39;村上春树&#39;, &#39;日本&#39; ),</span><br><span class="line">    ( 2, &#39;莫言&#39;, &#39;中国&#39; ),</span><br><span class="line">    ( 3, &#39;冯唐&#39;, &#39;中国&#39; ),</span><br><span class="line">    ( 4, &#39;金庸&#39;, &#39;中国&#39; );</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表copy，复制author表的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy LIKE author;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表copy2，复制author表的结构和数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT * FROM author;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表copy3，复制author表的部分数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy3</span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author </span><br><span class="line">WHERE nation&#x3D;&#39;中国&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表copy4，复制author表的部分字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE copy4 </span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author</span><br><span class="line">WHERE 0;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p><img data-src="/2020/09/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1576832538927.png" alt="1576832538927"></p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>TINYINT、SMALLINT、MEDIUMINT、INT/INTEGER、BIGINT</p>
<p>特点：</p>
<ol>
<li>都可以设置无符号和有符号，默认有符号，通过 UNSIGNED 设置无符号</li>
<li>如果超出了范围，会报out or range异常，插入临界值</li>
<li>长度可以不指定，默认会有一个长度，长度代表显示的最大宽度，如果不够则左边用0填充，但需要搭配ZEROFILL，并且默认变为无符号整型</li>
</ol>
<p>如何设置无符号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_int(</span><br><span class="line">    t1 INT,</span><br><span class="line">    t2 INT unsigned </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>显示长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_int(</span><br><span class="line">    t1 INT(7) ZEROFILL,</span><br><span class="line">    t2 INT(7) ZEROFILL </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p><strong>定点数：</strong>DECIMAL(M,D)</p>
<p><strong>浮点数：</strong>FLOAT(M,D) DOUBLE(M,D)</p>
<p><strong>特点：</strong></p>
<ol>
<li>M代表整数部位+小数部位的个数，D代表小数部位</li>
<li>如果超出范围，则报out or range异常，并且插入临界值</li>
<li>M和D都可以省略，但对于定点数，M默认为10，D默认为0</li>
<li>如果精度要求较高，则优先考虑使用定点数</li>
</ol>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p><img data-src="/2020/09/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1576833229769.png" alt="1576833229769"></p>
<p>char、varchar、binary、varbinary、enum(用于保存枚举)、set(用于保存集合)、text、blob</p>
<p>char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1</p>
<p>varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略</p>
<p>Enum：又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。</p>
<p>Set：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区别是：SET类型一次可以选取多个成员，而Enum只能选一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_char(</span><br><span class="line">    c1 ENUM(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_char VALUES(&#39;a&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;b&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;c&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;m&#39;);    --&gt; 会插入空字符 &#39;&#39;</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;A&#39;);    --&gt;  会插入 &#39;a&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_set(</span><br><span class="line">    s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_set VALUES(&#39;a&#39;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;A,B&#39;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;a,c,d&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h3><p><img data-src="/2020/09/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1576833502245.png" alt="1576833502245"></p>
<p>year年 date日期 time时间 datetime 日期+时间 timestamp 日期+时间 ，比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间</p>
<h2 id="常见的约束"><a href="#常见的约束" class="headerlink" title="常见的约束"></a>常见的约束</h2><ul>
<li>NOT NULL：非空，该字段的值必填</li>
<li>UNIQUE：唯一，该字段的值不可重复，可以为空</li>
<li>DEFAULT：默认，该字段的值不用手动插入有默认值</li>
<li>CHECK：检查，mysql不支持（但是设置并不会报错，只是没有效果）</li>
<li>PRIMARY KEY：主键，该字段的值不可重复并且非空 unique+not null</li>
<li>FOREIGN KEY：外键，该字段的值引用了另外的表的字段</li>
</ul>
<p><strong>添加约束的时机</strong></p>
<ol>
<li>创建表时</li>
<li>修改表时(在添加数据之前)</li>
</ol>
<p><strong>约束的添加的分类：</strong></p>
<ol>
<li><p>列级约束：</p>
<p>六大约束语法上都支持，但外键约束没有效果</p>
</li>
<li><p>表级约束：</p>
<p>除了非空、默认，其他的都支持</p>
</li>
</ol>
<h3 id="主键和唯一"><a href="#主键和唯一" class="headerlink" title="主键和唯一"></a>主键和唯一</h3><p><strong>区别：</strong></p>
<ol>
<li>一个表至多有一个主键，但可以有多个唯一</li>
<li>主键不允许为空，唯一可以为空</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">保证唯一性</th>
<th align="center">是否允许为空</th>
<th align="center">一个表中可以有多少个</th>
<th align="center">是否允许组合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主键</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">至多有1个</td>
<td align="center">√，但不推荐</td>
</tr>
<tr>
<td align="center">唯一</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">可以有多个</td>
<td align="center">√，但不推荐</td>
</tr>
</tbody></table>
<p><strong>外键：</strong></p>
<ol>
<li>要求在从表设置外键关系</li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</li>
<li>主表的关联列<code>必须是一个key</code>（一般是主键或唯一）</li>
<li>插入数据时，先插入主表，再插入从表</li>
<li>删除数据时，先删除从表，再删除主表</li>
</ol>
<h3 id="创建表时添加约束"><a href="#创建表时添加约束" class="headerlink" title="创建表时添加约束"></a>创建表时添加约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    字段名 字段类型 列级约束,</span><br><span class="line">    字段名 字段类型,</span><br><span class="line">    表级约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="添加列级约束"><a href="#添加列级约束" class="headerlink" title="添加列级约束"></a>添加列级约束</h3><p>直接在字段名和类型后面追加 约束类型即可。</p>
<p>只支持：默认、非空、主键、唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个数据库</span><br><span class="line">CREATE DATABASE students;</span><br><span class="line">USE students;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stuinfo (</span><br><span class="line">    id INT PRIMARY KEY,#主键</span><br><span class="line">    stuName VARCHAR ( 20 ) NOT NULL UNIQUE,#非空并且唯一</span><br><span class="line">    gender CHAR ( 1 ) CHECK ( gender &#x3D; &#39;男&#39; OR gender &#x3D; &#39;女&#39; ),#检查</span><br><span class="line">    seat INT UNIQUE,#唯一</span><br><span class="line">    age INT DEFAULT 18,#默认约束</span><br><span class="line">    majorId INT REFERENCES major ( id ) #外键，(没有效果)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE major(</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    majorName VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>

<h3 id="添加表级约束"><a href="#添加表级约束" class="headerlink" title="添加表级约束"></a>添加表级约束</h3><p>在各个字段的最下面</p>
<p>【constraint 约束名】 约束类型(字段名)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo (</span><br><span class="line">    id INT,</span><br><span class="line">    stuname VARCHAR ( 20 ),</span><br><span class="line">    gender CHAR ( 1 ),</span><br><span class="line">    seat INT,</span><br><span class="line">    age INT,</span><br><span class="line">    majorid INT,</span><br><span class="line">    CONSTRAINT pk PRIMARY KEY ( id ),#主键</span><br><span class="line">    CONSTRAINT uq UNIQUE ( seat ),#唯一键</span><br><span class="line">    CONSTRAINT ck CHECK ( gender &#x3D; &#39;男&#39; OR gender &#x3D; &#39;女&#39; ),#检查</span><br><span class="line">    CONSTRAINT fk_stuinfo_major FOREIGN KEY ( majorid ) REFERENCES major ( id ) #外键</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="通用写法"><a href="#通用写法" class="headerlink" title="通用写法"></a>通用写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo (</span><br><span class="line">        id INT PRIMARY KEY,</span><br><span class="line">        stuname VARCHAR ( 20 ),</span><br><span class="line">        sex CHAR ( 1 ),</span><br><span class="line">        age INT DEFAULT 18,</span><br><span class="line">        seat INT UNIQUE,</span><br><span class="line">        majorid INT,</span><br><span class="line">    CONSTRAINT fk_stuinfo_major FOREIGN KEY ( majorid ) REFERENCES major ( id ) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="修改表时添加约束"><a href="#修改表时添加约束" class="headerlink" title="修改表时添加约束"></a>修改表时添加约束</h3><ul>
<li><p>添加列级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加表级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">    id INT,</span><br><span class="line">    stuname VARCHAR(20),</span><br><span class="line">    gender CHAR(1),</span><br><span class="line">    seat INT,</span><br><span class="line">    age INT,</span><br><span class="line">    majorid INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>添加非空约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加默认约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加主键</p>
<p>① 列级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p>@ 表级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD PRIMARY KEY(id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加唯一</p>
<p>① 列级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</span><br></pre></td></tr></table></figure>

<p>② 表级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo ADD UNIQUE(seat);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加外键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo </span><br><span class="line">ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="修改表时删除约束"><a href="#修改表时删除约束" class="headerlink" title="修改表时删除约束"></a>修改表时删除约束</h3><ol>
<li><p>删除非空约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除默认约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo DROP INDEX seat;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自增长列"><a href="#自增长列" class="headerlink" title="自增长列"></a>自增长列</h3><p>不用手动插入值，可以自动提供序列值，默认从1开始，步长为1</p>
<p><code>auto_increment_increment</code></p>
<p>如果要更改起始值：手动插入值</p>
<p>如果要更改步长：更改系统变量：<code>set auto_increment_increment=值;</code></p>
<ol>
<li>一个表至多有一个自增长列</li>
<li>自增长列只能支持数值型</li>
<li>自增长列必须为一个key</li>
</ol>
<h4 id="创建表时设置自增长列"><a href="#创建表时设置自增长列" class="headerlink" title="创建表时设置自增长列"></a>创建表时设置自增长列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表(</span><br><span class="line">    字段名 字段类型 约束 auto_increment</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="修改表时设置自增长列"><a href="#修改表时设置自增长列" class="headerlink" title="修改表时设置自增长列"></a>修改表时设置自增长列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束 auto_increment</span><br></pre></td></tr></table></figure>

<h4 id="删除自增长列"><a href="#删除自增长列" class="headerlink" title="删除自增长列"></a>删除自增长列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表 modify column 字段名 字段类型 约束 </span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>TCL：<code>Transaction Control Language</code> 事务控制语言</p>
<p>事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>
<p>一个或一组sql语句组成一个执行单元，这个执行单元要么<strong>全部执行</strong>，要么<strong>全部不执行</strong>。</p>
<ul>
<li>概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。</li>
<li>通过show engines；来查看mysql支持的存储引擎。</li>
<li>在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中<code>innodb</code>支持事务，而myisam、memory等不支持</li>
</ul>
<h2 id="转账案例"><a href="#转账案例" class="headerlink" title="转账案例"></a>转账案例</h2><p>张三丰转给郭襄500元</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 张三丰  1000</span><br><span class="line"># 郭襄    1000</span><br><span class="line"></span><br><span class="line">update 表 set 张三丰的余额&#x3D;张三丰的余额-500 where name&#x3D;&#39;张三丰&#39;</span><br><span class="line"></span><br><span class="line">#　中间发生意外，张三丰的余额少了500，而郭襄的余额并没有增加</span><br><span class="line"></span><br><span class="line">update 表 set 郭襄的余额&#x3D;郭襄的余额+500 where name&#x3D;&#39;郭襄&#39;</span><br></pre></td></tr></table></figure>

<h2 id="事物的特性-ACID"><a href="#事物的特性-ACID" class="headerlink" title="事物的特性( ACID )"></a>事物的特性( ACID )</h2><ol>
<li><p><strong>原子性</strong>（Atomicity）</p>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
</li>
<li><p><strong>一致性</strong>（Consistency）</p>
<p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性</strong>（Isolation）</p>
<p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性</strong>（Durability）</p>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
</li>
</ol>
<h2 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h2><h3 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h3><p>事务没有明显的开启和结束的标记，比如insert、update、delete语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行完表中id列为1的那一行数据就直接被删除了</span><br><span class="line">delete from 表 where id &#x3D;1;</span><br></pre></td></tr></table></figure>

<h3 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h3><p>事务具有明显的开启和结束的标记</p>
<p><strong>前提</strong>：必须先设置自动提交功能为禁用 <code>set autocommit=0;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看自动提交是否开启</span><br><span class="line">SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br><span class="line"></span><br><span class="line"># 查看数据库引擎</span><br><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<h3 id="开启事务步骤"><a href="#开启事务步骤" class="headerlink" title="开启事务步骤"></a>开启事务步骤</h3><ol>
<li><p>开启事务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关闭自动提交</span><br><span class="line">set autocommit&#x3D;0;</span><br><span class="line"></span><br><span class="line">#　开启事物（可选）</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写事务中的sql语句（select insert update delete）</p>
</li>
<li><p>可选：<code>savepoint 节点名</code>；设置回滚点</p>
</li>
<li><p>结束事务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit;提交事务</span><br><span class="line"># 或者</span><br><span class="line">rollback;回滚事务</span><br><span class="line"># 或者</span><br><span class="line">rollback to 回滚点名;回滚到指定的地方</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h2><ol>
<li><p>事务的并发问题是如何发生的？</p>
<p>多个事务 同时 操作 同一个数据库的相同数据时</p>
</li>
<li><p>并发问题都有哪些？</p>
<p><strong>脏读:</strong> 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的</p>
<p><strong>不可重复读:</strong> 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了(在一个事物中不管读多少次，读取的数据应该都一样)</p>
<p><strong>幻读:</strong> 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行</p>
</li>
<li><p>如何解决并发问题</p>
<p>通过设置隔离级别来解决并发问题</p>
</li>
</ol>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>√：已解决    ×：未解决</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read uncommitted:读未提交</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">read committed：读已提交</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">repeatable read：可重复读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">serializable：串行化</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><code>mysql</code>中默认 第三个隔离级别 <code>repeatable read</code></p>
<p><code>oracle</code>中默认第二个隔离级别 <code>read committed</code></p>
<p><strong>查看隔离级别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure>

<p><strong>设置隔离级别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置当前 mySQL 连接的隔离级别: </span><br><span class="line">set transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line"># 设置数据库系统的全局的隔离级别:</span><br><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<h2 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h2><ol>
<li><p>事务的使用步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"># 编写一组事务的语句</span><br><span class="line">UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;张无忌&#39;;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;赵敏&#39;;</span><br><span class="line"></span><br><span class="line"># 结束事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"># COMMIT;</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务对于DELETE和TRUNCATE处理的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">DELETE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<p>TRUNCATE 无法回滚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">TRUNCATE TABLE account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
</li>
<li><p>savepoint 的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id&#x3D;25;</span><br><span class="line">SAVEPOINT a;#设置保存点</span><br><span class="line">DELETE FROM account WHERE id&#x3D;28;</span><br><span class="line">ROLLBACK TO a;#回滚到保存点</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中 使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果</p>
<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>多个地方用到同样的查询结果</li>
<li>该查询结果使用的sql语句较复杂</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>简化sql语句</li>
<li>提高了sql的重用性</li>
<li>保护基表的数据，提高了安全性</li>
</ol>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_v1 AS SELECT</span><br><span class="line">    last_name,</span><br><span class="line">    salary,</span><br><span class="line">    email </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">WHERE</span><br><span class="line">    phone_number LIKE &#39;011%&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建视图，查询每个部门的最高工资,筛选出高于12000的</span><br><span class="line">DROP VIEW emp_v2;</span><br><span class="line">CREATE VIEW emp_v2 AS SELECT</span><br><span class="line">department_id,</span><br><span class="line">MAX( salary ) max_salary </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">GROUP BY</span><br><span class="line">    department_id </span><br><span class="line">HAVING</span><br><span class="line">    max_salary &gt; 12000;</span><br><span class="line"></span><br><span class="line"># 根据创建的视图连接departments表查询部门信息</span><br><span class="line">SELECT</span><br><span class="line">    d.*,</span><br><span class="line">    ev2.max_salary </span><br><span class="line">FROM</span><br><span class="line">    departments d</span><br><span class="line">    JOIN emp_v2 ev2 </span><br><span class="line">    ON d.department_id &#x3D; ev2.department_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询姓名中包含a字符的员工名、部门名和工种信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询员工名、部门名和工种信息</span><br><span class="line">CREATE VIEW emp_v3 AS SELECT</span><br><span class="line">e.last_name,</span><br><span class="line">d.department_name,</span><br><span class="line">j.job_title </span><br><span class="line">FROM</span><br><span class="line">    employees e</span><br><span class="line">    LEFT JOIN departments d ON e.department_id &#x3D; d.department_id</span><br><span class="line">    LEFT JOIN jobs j ON e.job_id &#x3D; j.job_id;</span><br><span class="line"></span><br><span class="line"># 筛选出姓名中包含a字符的员工</span><br><span class="line">SELECT * FROM emp_v3 WHERE last_name LIKE &#39;%a%&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询各部门的平均工资级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询各部门的平均工资</span><br><span class="line">CREATE VIEW emp_v4 AS SELECT</span><br><span class="line">AVG( salary ) avg_salary,</span><br><span class="line">department_id </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">GROUP BY</span><br><span class="line">    department_id;</span><br><span class="line"></span><br><span class="line"># 查询各部门的平均工资级别</span><br><span class="line">SELECT</span><br><span class="line">    department_id,</span><br><span class="line">    j.grade_level </span><br><span class="line">FROM</span><br><span class="line">    emp_v4 ev4</span><br><span class="line">    LEFT JOIN job_grades j </span><br><span class="line">    ON ev4.avg_salary BETWEEN j.lowest_sal </span><br><span class="line">    AND j.highest_sal</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询平均工资最低的部门信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    d.*,</span><br><span class="line">    ev4.avg_salary </span><br><span class="line">FROM</span><br><span class="line">    departments d</span><br><span class="line">    JOIN ( SELECT * FROM emp_v4 ORDER BY avg_salary LIMIT 1 ) ev4 </span><br><span class="line">    ON d.department_id &#x3D; ev4.department_id</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h2><p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view  视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as </span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>

<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图名,视图名,...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW emp_v1,emp_v2,emp_v3,emp_v4;</span><br></pre></td></tr></table></figure>

<h2 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC 视图名;</span><br><span class="line"></span><br><span class="line">SHOW CREATE VIEW 视图名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_v1 AS SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">    employees;</span><br><span class="line"></span><br><span class="line">DESC emp_v1;</span><br><span class="line"></span><br><span class="line">SHOW CREATE VIEW emp_v1;</span><br></pre></td></tr></table></figure>

<h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><p>视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的。</p>
<ul>
<li>包含以下关键字的sql语句：分组函数、distinct、group by</li>
<li>having、union或者union all</li>
<li>常量视图</li>
<li>Select中包含子查询</li>
<li>join</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<h3 id="案例-10"><a href="#案例-10" class="headerlink" title="案例"></a>案例</h3><ol>
<li><p>张飞能否成功插入？</p>
<p>不能，原表中没有annual salary那一列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建视图，查询员工的姓名，邮箱和年薪</span><br><span class="line"></span><br><span class="line">CREATE </span><br><span class="line">    OR REPLACE VIEW myv1 AS SELECT</span><br><span class="line">    last_name,</span><br><span class="line">    email,</span><br><span class="line">    salary * 12 *(1+IFNULL ( commission_pct, 0 )) &quot;annual salary&quot; </span><br><span class="line">FROM</span><br><span class="line">    employees;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line">INSERT INTO myv1 VALUES(&#39;张飞&#39;,&#39;zf@qq.com&#39;,94862.00);</span><br></pre></td></tr></table></figure>
</li>
<li><p>张飞能否成功插入？</p>
<p>能，并且原表中也存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建视图，查询员工的姓名和邮箱</span><br><span class="line"></span><br><span class="line">CREATE </span><br><span class="line">    OR REPLACE VIEW myv1 AS SELECT</span><br><span class="line">    last_name,</span><br><span class="line">    email</span><br><span class="line">FROM</span><br><span class="line">    employees;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line">INSERT INTO myv1 VALUES(&#39;张飞&#39;,&#39;zf@qq.com&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>能否将张飞修改为张无忌？</p>
<p>能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE myv1 SET last_name &#x3D; &#39;张无忌&#39; WHERE last_name&#x3D;&#39;张飞&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>能否干掉张无忌？</p>
<p>能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM myv1 WHERE last_name &#x3D; &#39;张无忌&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>能否将10号部门的最高薪水改为9000？</p>
<p>不能 ，包含group by和分组函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#　创建视图，查询每个部门的最高工资</span><br><span class="line">CREATE </span><br><span class="line">    OR REPLACE VIEW myv1 AS SELECT</span><br><span class="line">    MAX( salary ) m,</span><br><span class="line">    department_id </span><br><span class="line">FROM</span><br><span class="line">    employees </span><br><span class="line">GROUP BY</span><br><span class="line">    department_id;</span><br><span class="line"></span><br><span class="line">＃ 将10号部门的最高薪水改为9000</span><br><span class="line">UPDATE myv1 SET m&#x3D;9000 WHERE department_id&#x3D;10;</span><br></pre></td></tr></table></figure>
</li>
<li><p>能否更改？</p>
<p>不能，常量视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv2</span><br><span class="line">AS</span><br><span class="line">SELECT &#39;john&#39; NAME;</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">UPDATE myv2 SET NAME&#x3D;&#39;lucy&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>能够将最高工资列修改为100000？</p>
<p>不能，select中包含子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv3 AS </span><br><span class="line">SELECT department_id,( SELECT MAX( salary ) FROM employees ) 最高工资 </span><br><span class="line">FROM</span><br><span class="line">    departments;</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line"></span><br><span class="line">UPDATE myv3 SET 最高工资&#x3D;100000;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改和插入能成功吗？</p>
<p>可以更新，但是不能插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建视图，查询员工名与部门名</span><br><span class="line">CREATE </span><br><span class="line">    OR REPLACE VIEW myv4 AS SELECT</span><br><span class="line">    last_name,</span><br><span class="line">    department_name </span><br><span class="line">FROM</span><br><span class="line">    employees e</span><br><span class="line">    JOIN departments d ON e.department_id &#x3D; d.department_id;</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">UPDATE myv4 SET last_name  &#x3D; &#39;张飞&#39; WHERE last_name&#x3D;&#39;Whalen&#39;;</span><br><span class="line"># 插入</span><br><span class="line">INSERT INTO myv4 VALUES(&#39;陈真&#39;,&#39;Acc&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>能修改吗？</p>
<p>不能，from一个不能更新的视图，myv3中select使用了子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE </span><br><span class="line">    OR REPLACE VIEW myv5 AS SELECT</span><br><span class="line">    * </span><br><span class="line">FROM</span><br><span class="line">    myv3;</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">UPDATE myv5 SET 最高工资&#x3D;10000 WHERE department_id&#x3D;60;</span><br></pre></td></tr></table></figure>
</li>
<li><p>能修改吗？</p>
<p>不能，where子句的子查询引用了from子句中的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询所有的领导信息</span><br><span class="line">CREATE OR REPLACE VIEW myv6</span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">SELECT last_name,email,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN(</span><br><span class="line">    SELECT  manager_id</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE manager_id IS NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">UPDATE myv6 SET salary&#x3D;10000 WHERE last_name &#x3D; &#39;k_ing&#39;;</span><br></pre></td></tr></table></figure>

<p>查询领导Id（将所有员工的上级Id查出来，这些Id就是领导Id）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="视图和表的对比"><a href="#视图和表的对比" class="headerlink" title="视图和表的对比"></a>视图和表的对比</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">关键字</th>
<th align="center">是否占用物理空间</th>
<th align="center">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">视图</td>
<td align="center">create view</td>
<td align="center">占用较小，只保存sql逻辑</td>
<td align="center">一般用于查询</td>
</tr>
<tr>
<td align="center">表</td>
<td align="center">create table</td>
<td align="center">保存实际的数据</td>
<td align="center">增删改查</td>
</tr>
</tbody></table>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>系统变量：</p>
<ul>
<li>全局变量</li>
<li>会话变量</li>
</ul>
<p>说明：变量由系统定义，不是用户定义，属于服务器层面</p>
<p>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br>​    全局变量作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启（重启之后会恢复到你修改前的状态，修改要永久生效，需要修改配置文件）</p>
<ol>
<li><p>查看所有系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 全局</span><br><span class="line">show global variables;</span><br><span class="line"></span><br><span class="line">#会话</span><br><span class="line">show [session] variables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看满足条件的部分系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global | [session] variables like &#39;%char%&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定的系统变量的值（<code>带.</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@global |【@@session】.系统变量名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为某个系统变量赋值</p>
<p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global|[session]系统变量名&#x3D;值;</span><br></pre></td></tr></table></figure>

<p>方式二（<code>带.</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@global|【@@session】.系统变量名&#x3D;值;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"># 查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line"># 查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line"># 为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit&#x3D;0;</span><br><span class="line">SET GLOBAL autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line"># 查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line"># 查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line"># 为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;</span><br><span class="line">SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p>变量由用户自定义，而不是系统提供的</p>
<p>作用域：针对于当前会话（连接）有效，作用域同于会话变量</p>
<p><strong>声明并初始化</strong></p>
<p>赋值操作符：<code>=</code>或<code>:=</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @变量名&#x3D;值;</span><br><span class="line">SET @变量名:&#x3D;值;</span><br><span class="line">SELECT @变量名:&#x3D;值;</span><br></pre></td></tr></table></figure>

<p><strong>更新变量的值</strong></p>
<ul>
<li><p>方式一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @变量名&#x3D;值;</span><br><span class="line">SET @变量名:&#x3D;值;</span><br><span class="line">SELECT @变量名:&#x3D;值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将某个字段的值赋给 自定义变量</span><br><span class="line">SELECT 字段 INTO @变量名</span><br><span class="line">FROM 表;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>查看变量的值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @变量名;</span><br></pre></td></tr></table></figure>

<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>作用域：仅仅在定义它的begin end块中有效</p>
<p>应在 begin end中的第一句话声明</p>
<p><strong>声明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">    变量名 类型;</span><br><span class="line">    ...</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># 值的类型要和前面声明的类型一致</span><br><span class="line">DECLARE </span><br><span class="line">    变量名 类型 【DEFAULT 值】;</span><br><span class="line">    ...</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>赋值（更新变量的值）</strong></p>
<ul>
<li><p>方式一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET 局部变量名&#x3D;值;</span><br><span class="line">SET 局部变量名:&#x3D;值;</span><br><span class="line">SELECT 局部变量名:&#x3D;值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段 INTO 具备变量名</span><br><span class="line">FROM 表;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>查看变量的值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>

<p><strong>用户变量和局部变量的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">作用域</th>
<th align="center">定义和使用的位置</th>
<th align="center">语法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自定义变量</td>
<td align="center">当前会话</td>
<td align="center">会话中的任何地方</td>
<td align="center">必须加@符号，不用限定类型</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">BEGIN END中</td>
<td align="center">只能在BEGIN END中，且为第一句话</td>
<td align="center">一般不用加@符号，需要限定类型</td>
</tr>
</tbody></table>
<h2 id="案例-11"><a href="#案例-11" class="headerlink" title="案例"></a>案例</h2><ol>
<li><p>声明两个用户（自定义）变量，求和并打印</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @m&#x3D;1;</span><br><span class="line">SET @n&#x3D;1;</span><br><span class="line">SET @sum&#x3D;@m+@n;</span><br><span class="line">SELECT @sum;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p><strong>什么是存储过程：</strong></p>
<p>事先经过编译并存储在数据库中的一段sql语句的集合。</p>
<p>类似于java中的方法</p>
<p><strong>使用好处</strong></p>
<ol>
<li>简化应用开发人员的很多工作</li>
<li>减少数据在数据库和应用服务器之间的传输</li>
<li>提高了数据处理的效率</li>
<li>一组预先编译好的SQL语句的集合，理解成批处理语句</li>
</ol>
<h2 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(参数列表)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">    存储过程体（一组合法的SQL语句）</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>参数列表包含三部分</strong></p>
<ul>
<li>参数模式</li>
<li>参数名</li>
<li>参数类型</li>
</ul>
<p>例：in stuname varchar(20)</p>
<p><strong>参数模式：</strong></p>
<p><code>in</code>：该参数可以作为输入，也就是该参数需要调用方传入值</p>
<p><code>out</code>：该参数可以作为输出，也就是该参数可以作为返回值</p>
<p><code>inout</code>：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p>
<ul>
<li><p>如果存储过程体仅仅只有一句话，begin end可以省略</p>
</li>
<li><p>存储过程体中的每条sql语句的结尾要求必须加分号。</p>
</li>
<li><p>存储过程的结尾可以使用 delimiter 重新设置（避免与存储过程体的分号混淆）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter 结束标记</span><br><span class="line"># 例</span><br><span class="line">delimiter $</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>例：</strong></p>
<p>插入到admin表中五条记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE girls;</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp1()</span><br><span class="line">BEGIN</span><br><span class="line">    INSERT INTO admin(username,&#96;password&#96;) </span><br><span class="line">    VALUES</span><br><span class="line">    (&#39;john1&#39;,&#39;0000&#39;),(&#39;lily&#39;,&#39;0000&#39;),(&#39;rose&#39;,&#39;0000&#39;),(&#39;jack&#39;,&#39;0000&#39;),(&#39;tom&#39;,&#39;0000&#39;);</span><br><span class="line">END $</span><br></pre></td></tr></table></figure>

<h2 id="调用语法"><a href="#调用语法" class="headerlink" title="调用语法"></a>调用语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(实参列表);</span><br><span class="line"></span><br><span class="line">CALL myp1();</span><br><span class="line"># 存储过程定义完结束标记$，那么此处的结束标记不用&#96;;&#96;，使用$</span><br><span class="line">CALL myp1()$</span><br></pre></td></tr></table></figure>

<h2 id="创建带in模式参数的-存储过程"><a href="#创建带in模式参数的-存储过程" class="headerlink" title="创建带in模式参数的 存储过程"></a>创建带in模式参数的 存储过程</h2><p>创建存储过程实现 根据女神名，查询对应的男神信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT bo.*</span><br><span class="line">    FROM boys bo</span><br><span class="line">    RIGHT JOIN beauty b ON bo.id &#x3D; b.boyfriend_id</span><br><span class="line">    WHERE b.name&#x3D;beautyName;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL myp2(&#39;赵敏&#39;);</span><br></pre></td></tr></table></figure>

<p>创建存储过程实现，判断用户是否登录成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp3(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE result INT DEFAULT 0;    #声明并初始化</span><br><span class="line"></span><br><span class="line">    SELECT COUNT(*) INTO result    #赋值</span><br><span class="line">    FROM admin</span><br><span class="line">    WHERE admin.username &#x3D; username</span><br><span class="line">    AND admin.password &#x3D; PASSWORD;</span><br><span class="line"></span><br><span class="line">    SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);    #使用</span><br><span class="line">END $</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL myp3(&#39;john&#39;,&#39;8888&#39;);</span><br><span class="line">CALL myp3(&#39;john&#39;,&#39;1234&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="创建out模式参数的存储过程"><a href="#创建out模式参数的存储过程" class="headerlink" title="创建out模式参数的存储过程"></a>创建out模式参数的存储过程</h2><p>根据输入的女神名，返回对应的男神名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp4(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT bo.boyname INTO boyname</span><br><span class="line">    FROM boys bo</span><br><span class="line">    RIGHT JOIN</span><br><span class="line">    beauty b ON b.boyfriend_id &#x3D; bo.id</span><br><span class="line">    WHERE b.name&#x3D;beautyName ;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 调用 使用自定义变量接收</span><br><span class="line">CALL myp4(&#39;赵敏&#39;,@name);</span><br><span class="line">SELECT @name;</span><br></pre></td></tr></table></figure>

<p>根据输入的女神名，返回对应的男神名和魅力值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp5(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) </span><br><span class="line">BEGIN</span><br><span class="line">    SELECT boys.boyname ,boys.usercp INTO boyname,usercp</span><br><span class="line">    FROM boys </span><br><span class="line">    RIGHT JOIN</span><br><span class="line">    beauty b ON b.boyfriend_id &#x3D; boys.id</span><br><span class="line">    WHERE b.name&#x3D;beautyName ;</span><br><span class="line"></span><br><span class="line">END $</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL myp5(&#39;小昭&#39;,@name,@cp);</span><br><span class="line">SELECT @name,@cp;</span><br></pre></td></tr></table></figure>

<h2 id="创建带inout模式参数的存储过程"><a href="#创建带inout模式参数的存储过程" class="headerlink" title="创建带inout模式参数的存储过程"></a>创建带inout模式参数的存储过程</h2><p>传入a和b两个值，最终a和b都翻倍并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE OR REPLACE PROCEDURE myp5(INOUT a INT,INOUT b INT)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">    SET a:&#x3D;a*2;</span><br><span class="line">    SET b:&#x3D;b*2;</span><br><span class="line"></span><br><span class="line">END $</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @m&#x3D;10;</span><br><span class="line">SET @n&#x3D;20;</span><br><span class="line">CALL myp5(@m,@n);</span><br><span class="line">SELECT @m,@n;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程的删除"><a href="#存储过程的删除" class="headerlink" title="存储过程的删除"></a>存储过程的删除</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 存储过程一次只能删除一个</span><br><span class="line">DROP PROCEDURE 存储过程名;</span><br></pre></td></tr></table></figure>

<h2 id="查看存储过程的信息"><a href="#查看存储过程的信息" class="headerlink" title="查看存储过程的信息"></a>查看存储过程的信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE myp5;</span><br></pre></td></tr></table></figure>

<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><h2 id="存储过程与存储函数的区别"><a href="#存储过程与存储函数的区别" class="headerlink" title="存储过程与存储函数的区别"></a>存储过程与存储函数的区别</h2><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新</p>
<p>存储函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p>
<h2 id="创建语法-1"><a href="#创建语法-1" class="headerlink" title="创建语法"></a>创建语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">    函数体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<ul>
<li>参数列表 包含两部分：参数名，参数类型</li>
<li>函数体：<ul>
<li>肯定会有return语句，如果没有会报错 如果return语句没有放在函数体的最后也不报错，但不建议</li>
<li>函数体中仅有一句话，则可以省略begin end</li>
</ul>
</li>
<li>使用 delimiter语句设置结束标记</li>
</ul>
<h2 id="调用语法-1"><a href="#调用语法-1" class="headerlink" title="调用语法"></a>调用语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(参数列表);</span><br></pre></td></tr></table></figure>

<h2 id="无参有返回"><a href="#无参有返回" class="headerlink" title="无参有返回"></a>无参有返回</h2><p>返回公司的员工个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE FUNCTION myf1() RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">    DECLARE c INT DEFAULT 0;    #定义局部变量</span><br><span class="line">    SELECT COUNT(*) INTO c     #赋值</span><br><span class="line">    FROM employees;</span><br><span class="line">    RETURN c;</span><br><span class="line"></span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT myf1();</span><br></pre></td></tr></table></figure>

<h2 id="有参有返回"><a href="#有参有返回" class="headerlink" title="有参有返回"></a>有参有返回</h2><p>根据员工名，返回它的工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">    SET @sal&#x3D;0;    #定义用户变量 </span><br><span class="line">    SELECT salary INTO @sal    #赋值</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE last_name &#x3D; empName;</span><br><span class="line"></span><br><span class="line">    RETURN @sal;</span><br><span class="line"></span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT myf2(&#39;Kochhar&#39;);</span><br><span class="line"></span><br><span class="line">SELECT @sal;</span><br></pre></td></tr></table></figure>

<p>根据部门名，返回该部门的平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE sal DOUBLE ;</span><br><span class="line">    SELECT AVG(salary) INTO sal</span><br><span class="line">    FROM employees e</span><br><span class="line">    JOIN departments d ON e.department_id &#x3D; d.department_id</span><br><span class="line">    WHERE d.department_name&#x3D;deptName;</span><br><span class="line">    RETURN sal;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT myf3(&#39;IT&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="查看函数"><a href="#查看函数" class="headerlink" title="查看函数"></a>查看函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION myf3;</span><br></pre></td></tr></table></figure>

<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION myf3;</span><br></pre></td></tr></table></figure>

<p>创建函数，实现传入两个float，返回二者之和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE OR REPLACE FUNCTION myf3(num1 FLOAT,num2 FLOAT) RETURNS FLOAT(3,1)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE SUM FLOAT(3,1) DEFAULT 0;</span><br><span class="line">    SET SUM&#x3D;num1+num2;</span><br><span class="line">    RETURN SUM;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT myf3(15.5,15.3);    --&gt; 30.8</span><br></pre></td></tr></table></figure>

<h1 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h1><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h3><p><strong>语法</strong>：<code>if(条件,值1，值2)</code></p>
<p><strong>功能</strong>：实现双分支</p>
<p>应用在begin end中或外面</p>
<h3 id="case结构"><a href="#case结构" class="headerlink" title="case结构"></a>case结构</h3><p>类似java中的switch</p>
<p><strong>功能</strong>：实现多分支</p>
<p>应用在begin end 中或外面</p>
<p><strong>语法一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 表达式或字段</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2；</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br></pre></td></tr></table></figure>

<p><strong>语法二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2；</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br></pre></td></tr></table></figure>

<p>创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE OR REPLACE FUNCTION test_case(score DOUBLE) RETURNS CHAR</span><br><span class="line">BEGIN</span><br><span class="line">-- DECLARE result CHAR;</span><br><span class="line">CASE  </span><br><span class="line">    WHEN score&gt;90 THEN</span><br><span class="line">        RETURN &#39;A&#39;;</span><br><span class="line">    WHEN score&gt;80 THEN </span><br><span class="line">        RETURN &#39;B&#39;;</span><br><span class="line">    WHEN score&gt;60 THEN</span><br><span class="line">        RETURN &#39;C&#39;;</span><br><span class="line">    ELSE</span><br><span class="line">        RETURN &#39;D&#39;;</span><br><span class="line">END CASE;</span><br><span class="line"></span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT test_case(95);</span><br><span class="line"></span><br><span class="line">SELECT test_case(85);</span><br><span class="line"></span><br><span class="line">SELECT test_case(75);</span><br><span class="line"></span><br><span class="line">SELECT test_case(55);</span><br></pre></td></tr></table></figure>

<h3 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h3><p><strong>功能</strong>：实现多分支</p>
<p>只能放在begin end中</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>

<p>创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE OR REPLACE FUNCTION test_if(score DOUBLE) RETURNS CHAR </span><br><span class="line">BEGIN </span><br><span class="line">    DECLARE result CHAR;</span><br><span class="line">    IF score&gt;90 THEN</span><br><span class="line">        SET result:&#x3D;&#39;A&#39;;</span><br><span class="line">    ELSEIF score&gt;80 THEN</span><br><span class="line">        SET result:&#x3D;&#39;B&#39;;</span><br><span class="line">    ELSEIF score&gt;60 THEN</span><br><span class="line">        SET result:&#x3D;&#39;C&#39;;</span><br><span class="line">    ELSE</span><br><span class="line">        SET result:&#x3D;&#39;D&#39;;</span><br><span class="line">    END IF;</span><br><span class="line">    RETURN result;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT test_if(95);</span><br><span class="line"></span><br><span class="line">SELECT test_if(85);</span><br><span class="line"></span><br><span class="line">SELECT test_if(75);</span><br><span class="line"></span><br><span class="line">SELECT test_if(55);</span><br></pre></td></tr></table></figure>

<p>创建存储过程，如果工资&lt;2000,则删除，如果5000&gt;工资&gt;2000,则涨工资1000，否则涨工资500</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE OR REPLACE PROCEDURE test_if2(IN salary DOUBLE)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">    IF salary&lt;2000 THEN</span><br><span class="line">            DELETE FROM employees WHERE employees.salary&#x3D;salary;</span><br><span class="line">    ELSEIF 2000&lt;salary&lt;5000 THEN </span><br><span class="line">            UPDATE employees SET employees.salary&#x3D;employees.salary+1000 WHERE employees.salary&#x3D;salary; </span><br><span class="line">    ELSE</span><br><span class="line">            UPDATE employees SET employees.salary&#x3D;employees.salary+500 WHERE employees.salary&#x3D;salary; </span><br><span class="line">    END IF;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL test_if2(3300.00);</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p><strong>分类</strong>：<code>while</code>、<code>loop</code>、<code>repeat</code></p>
<p><strong>循环控制</strong>：</p>
<p><code>iterate</code>类似于 <code>continue</code>，继续，结束本次循环，继续下一次</p>
<p><code>leave</code> 类似于 <code>break</code>，跳出，结束当前所在的循环</p>
<p>只能放在begin end中</p>
<p><strong>标签</strong>：用上循环控制就必须要加</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[标签:] while 循环条件 do</span><br><span class="line">    循环体;</span><br><span class="line">end while [标签];</span><br></pre></td></tr></table></figure>

<p>批量插入，根据次数插入到admin表中多条记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE girls;</span><br><span class="line"></span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE OR REPLACE PROCEDURE test_while(IN total INT)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">WHILE i&lt;total DO</span><br><span class="line">    INSERT INTO admin VALUES(NULL,CONCAT(&#39;员工&#39;,i),&#39;8888&#39;);</span><br><span class="line">    SET i:&#x3D;i+1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL test_while(10);</span><br></pre></td></tr></table></figure>

<p>批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止 （需要加标签）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE OR REPLACE PROCEDURE test_while(IN total INT)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line"></span><br><span class="line">a:WHILE i&lt;&#x3D;total DO</span><br><span class="line">    IF i&gt;20 THEN LEAVE a;</span><br><span class="line">    END IF;</span><br><span class="line">    INSERT INTO admin VALUES(NULL,CONCAT(&#39;员工&#39;,i),&#39;8888&#39;);</span><br><span class="line">    SET i:&#x3D;i+1;</span><br><span class="line">END WHILE a;</span><br><span class="line"></span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE admin;</span><br><span class="line">CALL test_while(100);</span><br></pre></td></tr></table></figure>

<p>批量插入，根据次数插入到admin表中多条记录，只插入偶数次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE OR REPLACE PROCEDURE test_while(IN total INT)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">a:WHILE i&lt;&#x3D;total DO</span><br><span class="line">    SET i:&#x3D;i+1;</span><br><span class="line">    IF MOD(i,2)!&#x3D;0 THEN ITERATE a;</span><br><span class="line">    END IF;</span><br><span class="line">    INSERT INTO admin VALUES(NULL,CONCAT(&#39;员工&#39;,i),&#39;8888&#39;);</span><br><span class="line"></span><br><span class="line">END WHILE a;</span><br><span class="line"></span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE admin;</span><br><span class="line">CALL test_while(20);</span><br></pre></td></tr></table></figure>

<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[标签:] loop</span><br><span class="line"></span><br><span class="line">    循环体;</span><br><span class="line"></span><br><span class="line">end loop [标签];</span><br></pre></td></tr></table></figure>

<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[标签] repeat</span><br><span class="line">    循环体;</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat [标签];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><p>这篇<strong>《Git 学习笔记》</strong>主要记录的是 git 的一些知识点以及常用命令，属于入门级。推荐通读全文并试着自己操作一下；赶时间的话，可以直接阅读Git常用命令，会列出常用的命令。<strong>如文中有知识点写错，欢迎指正。</strong></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923094752490.png" alt="image-20200923094752490"></p>
<a id="more"></a>

<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><h2 id="Git-简史"><a href="#Git-简史" class="headerlink" title="Git 简史"></a>Git 简史</h2><p>同生活中的许多伟大事物一样，git 诞生于一个极富纷争大举创新的年代。</p>
<p>Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p>
<ul>
<li>速度</li>
<li>简单的设计</li>
<li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li>
<li>完全分布式</li>
<li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li>
</ul>
<p>自诞生于 2005 年以来，git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统</p>
<h2 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h2><p>一句话：Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><h2 id="centos7中安装Git"><a href="#centos7中安装Git" class="headerlink" title="centos7中安装Git"></a>centos7中安装Git</h2><h3 id="简单粗暴版"><a href="#简单粗暴版" class="headerlink" title="简单粗暴版"></a>简单粗暴版</h3><ol>
<li><p>查看是否安装了git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version <span class="comment">#查看git版本信息</span></span><br></pre></td></tr></table></figure>

<p>如果提示未找到命令，则表示没有安装</p>
</li>
<li><p>如果安装了git，但是版本过低，则使用该命令移除原来的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove git <span class="comment"># 移除原来的版本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看yum源仓库的git信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure>

<p>自动安装好git以及所需要的依赖。</p>
</li>
</ol>
<h3 id="使用源码包安装"><a href="#使用源码包安装" class="headerlink" title="使用源码包安装"></a>使用源码包安装</h3><ol>
<li><p>下载源码包</p>
<p>源码包下载地址：<a href="https://github.com/git/git/releases">https://github.com/git/git/releases</a></p>
<p>或者使用该命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt <span class="comment"># 进入opt目录，将源码包下载到该目录</span></span><br><span class="line">wget https://www.kernel.org/pub/software/scm/git/git-2.28.0.tar.gz <span class="comment"># 下载源码包</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf git-2.28.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel autoconf gcc-c++</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> git-2.28.0 <span class="comment"># 进入解压后的git源码包目录</span></span><br><span class="line">./configure --prefix=/usr/software/git <span class="comment"># 编译的时候用来指定程序存放路径 </span></span><br><span class="line">make prefix=/usr/software/git  <span class="comment"># 编译</span></span><br><span class="line">make install <span class="comment"># 安装</span></span><br></pre></td></tr></table></figure>

<p>扩展：<code>configure</code>是一个可执行脚本，它有很多选项，在待安装的源码路径下使用命令<code>./configure–help</code>输出详细的选项列表。其中，<code>prefix</code>选项是配置安装的路径，如果不配置该选项，安装后可执行文件默认放在<code>/usr/local/bin</code>，库文件默认放在<code>/usr/local/lib</code>，配置文件默认放在<code>/usr/local/etc</code>，其它的资源文件放在<code>/usr/local/share</code>，比较凌乱。</p>
<p>如果配置<code>prefix</code>，如：<code>./configure --prefix=/usr/software/git</code>可以把所有资源文件放在<code>/usr/software/git</code>的路径中，不会杂乱。如果想要卸载git，直接删除<code>/usr/software</code>目录下的<code>git</code>文件夹即可</p>
</li>
<li><p>添加环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/usr/software/git/bin&quot;</span> &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新环境变量，使其生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查git版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200917183904420.png" alt="image-20200917183904420"></p>
<p>出现git版本信息，就说明安装成功了</p>
</li>
</ol>
<h2 id="Windows10-中安装"><a href="#Windows10-中安装" class="headerlink" title="Windows10 中安装"></a>Windows10 中安装</h2><p>第一步：进入官网下载最新版Git。</p>
<p>官网下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001153944267.png" alt="image-20201001153944267"></p>
<p>第二步：双击下载好的Git安装包，弹出如下提示框：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001154201252.png" alt="image-20201001154201252"></p>
<p>第三步：直接点击上图的Next，选择安装路径，如下图：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001154529606.png" alt="image-20201001154529606"></p>
<p>第四步：选择好安装路径之后，一直点next，全部使用默认配置。安装完成，如下图所示：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001160915318.png" alt="image-20201001160915318"></p>
<p>取消<code>View Release Notes</code>前面的勾选，点击Next，至此安装完成。</p>
<p>安装完成后，单击鼠标右键，你会发现多出了<code>Git GUI Here</code>和<code>Git Bash Here</code>两项，如下图所示：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001161222615.png" alt="image-20201001161222615"></p>
<p>Git的GUI，也就是图形化界面做的不是那么好看，可以使用第三方的软件，如：SourceTree。</p>
<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><p>git 提供了一个叫做<code>git config</code> 的工具，专门用来配置或读取相应的工作环境变量，这些环境变量，决定了 git 在各个环节的具体工作方式和行为。这些变量存放在以下三个不同的地方（只有在进行相应的配置之后才会有出现这些配置文件）：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件: 包含系统上所有用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以使用 <code>--global</code> 选项让 git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li>
<li>当前项目的 git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该项目有效。 你可以传递 <code>--local</code> 选项让 git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 git 仓库中才能让该选项生效。）</li>
</ul>
<p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<p>你可以通过以下命令查看所有的配置以及它们所在的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure>

<h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中。</p>
<p>配置个人的用户名称和电子邮件地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;sleep&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sleep@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想修改这个信息</span></span><br><span class="line">git config --global user.name <span class="string">&quot;写新的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;新的邮箱&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想查看自己配置的用户名和电子邮件地址</span></span><br><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>

<p>如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， git 都会使用这些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，只要去掉 <code>--global</code> 选项来重新配置即可，新的配置会保存在当前项目的<code>.git/config</code>文件里</p>
<h2 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h2><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 git 当时能找到的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># git config --list</span></span><br><span class="line">user.name=sleep</span><br><span class="line">user.email=sleep@gmail.com</span><br></pre></td></tr></table></figure>

<p>你可能会看到重复的变量名，因为 git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，git 会使用这个命令找到的每一个变量的最后一个配置。</p>
<p>如果你想查看某一项的配置，你可以使用<code>git config &lt;key&gt;</code>命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># git config user.name</span></span><br><span class="line">sleep</span><br></pre></td></tr></table></figure>

<h1 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h1><p>什么是仓库呢？仓库又叫版本库，英文名为<strong>repository</strong>，可以简单理解成一个目录，这个目录里的所有文件可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，任何时刻都可以追踪历史，或者在将来的某个时刻还可以还原。</p>
<p><strong>在开始之前，先了解一些前置知识：</strong></p>
<p>所有的版本控制系统，只能跟踪文本文件的改动，比如TXT文件、网页、代码等，Git也不例外。对于图片、视频这些二进制文件，Git只能把二进制文件的每次改动串起来，也就是只知道图片从100kb改成了120kb，但是到底改了什么，Git不知道，也没法知道。但是二进制文件，同样是可以放入版本控制工具中进行管理的。</p>
<p>文本是有编码的，这里建议使用UTF-8编码。</p>
<p>如果使用过得是Windows系统，不建议使用<strong>记事本</strong>编辑文本文件，原因是记事本对UTF-8编码的文件支持度不是很好，容易出现奇葩问题。推荐使用Notepad++代替记事本，它不但功能强大，而且免费，使用时记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923150813612.png" alt="image-20200923150813612"></p>
<p>Notepad++下载地址：<a href="https://notepad-plus-plus.org/">https://notepad-plus-plus.org/</a></p>
<p><strong>创建git仓库的的方式有两种：</strong></p>
<ol>
<li>将尚未进行版本控制的本地目录转换为git仓库</li>
<li>从其它服务器<strong>克隆</strong>一个已存在的git仓库</li>
</ol>
<p>两种方式都会在你的本地机器上得到一个 git 仓库。</p>
<h2 id="在任意目录中初始化仓库"><a href="#在任意目录中初始化仓库" class="headerlink" title="在任意目录中初始化仓库"></a>在任意目录中初始化仓库</h2><p>如果你有一个尚未进行版本控制的项目目录，想要用 git 来管理它，那么首先需要进入该项目目录中。</p>
<p>进入目录中，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment"># 或者 对指定的目录进行版本控制</span></span><br><span class="line">git init newrepo</span><br></pre></td></tr></table></figure>

<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 git 仓库中所有的必须文件。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p>
<p>可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code> 进行提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对所有文件扩展名为.c的文件进行跟踪</span></span><br><span class="line">git add *.c</span><br><span class="line"><span class="comment"># 未指定扩展名，则表示这是一个文件夹</span></span><br><span class="line">git add <span class="built_in">test</span></span><br><span class="line"><span class="comment"># -m 对该次提交的说明</span></span><br><span class="line">git commit -m <span class="string">&#x27;初始化项目版本&#x27;</span></span><br></pre></td></tr></table></figure>

<p>稍后我们再逐一解释这些指令的行为。</p>
<p>现在我们来实践一下：</p>
<ol>
<li><p>新建一个文件夹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建learngit文件夹</span></span><br><span class="line">$ mkdir learngit</span><br><span class="line"><span class="comment"># 进入learnGit文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> learngit/</span><br><span class="line"><span class="comment"># 查看当前所在的目录（文件夹）</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/e/workspace/learngit <span class="comment"># 表示当前在E盘的workspace文件夹下的learngit文件夹中</span></span><br></pre></td></tr></table></figure>

<p><strong>Tip：</strong>新建的目录最好不要使用中文，包括它的上级目录，最好也不要有中文，以免出现奇怪的问题。</p>
</li>
<li><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> E:/workspace/learngit/.git/</span><br></pre></td></tr></table></figure>

<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository）。</p>
</li>
<li><p>git创建好仓库之后，会生成一个<code>.git</code>文件夹，它是个隐藏文件夹，主要是git用来跟踪管理版本库的，没事千万不要手动修改里面的文件，不然会多git仓库造成破坏。隐藏文件默认是不可见的，使用<code>ls -a</code>命令就可以看见它了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -a</span><br><span class="line">./  ../  .git/ <span class="comment"># ./ 表示当前目录  ../表示上一层目录</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>不一定必须在空目录下创建Git仓库，也可以选择一个已经有东西的目录。不过，不建议在公司使用自己正在开发的项目来学习Git，造成的后果，我可不负责任哦。</p>
<p>git仓库创建好了，现在使用Notepad++新建一个readme.txt文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>

<p>将这个文件放在<code>learngit</code>目录下，子目录也是可以的，如果放在learngit目录外面，那Git是找不到的，进不能进行版本管理。</p>
<p>把一个文件放到仓库只需要两步：</p>
<ol>
<li><p>用<code>git add</code>命令，将文件放入暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>

<p>执行完，没有任何消息，没有消息就是好消息，说明添加成功。</p>
</li>
<li><p>用<code>git commit</code>命令，把文件提交到本地仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;write a readme file&#x27;</span></span><br><span class="line">[master (root-commit) d1bdde3] write a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>

<p>此时readme.txt就被提交到了git仓库。</p>
</li>
</ol>
<h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p>如果你想获得一份已经存在了的 git 仓库的拷贝，就要用到<code>git clone</code>命令（类似SVN的checkout命令）。git 克隆的是该 git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库 （虽然可能会丢失某些服务器端的钩子（hook）设置，但是所有版本的数据仍在）。</p>
<p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code> 。 比如，要克隆 github 上的某个库，可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tiangoubot/learngit.git</span><br></pre></td></tr></table></figure>

<p>这个操作会在当前目录下创建一个名为 gitTest 的目录，并在这个目录下初始化一个<code>.git</code>文件夹（改文件加为隐藏文件），从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p>
<p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以指定新的目录名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tiangoubot/learngit.git myTest</span><br></pre></td></tr></table></figure>

<p>git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议。</p>
<h1 id="将文件添加到Git仓库"><a href="#将文件添加到Git仓库" class="headerlink" title="将文件添加到Git仓库"></a>将文件添加到Git仓库</h1><p>在前面的实战部分，已经体验过怎么将文件添加到本地的git仓库了。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923165017057.png" alt="image-20200923165017057"></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923165435138.png" alt="image-20200923165435138"></p>
<p>工作目录（实战中的<code>learngit</code>文件夹）下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。</p>
<p><strong>已跟踪：</strong>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 git 已经知道的文件。</p>
<p><strong>未跟踪：</strong>除了已跟踪的文件，都是未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 git 刚刚检出了它们， 而你尚未编辑过它们。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。下图为文件的状态变化周期</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200918022648284.png" alt="文件的状态变化周期"></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200918042109655.png" alt="小朋友你是否有很多问号"></p>
<p>接着往下看，看完还不懂，提上你40米长的大刀来砍我。</p>
<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><p>这里再次使用<code>learngit</code>目录，在上面的实践结束后，该目录下只有一个<code>readme.txt</code>文件，我们使用<code>git status</code>命令查看一下文件处于什么状态，使用此命令，会看到类似这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master <span class="comment"># 说明当前所在分支 master 为默认分支名</span></span><br><span class="line">nothing to commit, working tree clean <span class="comment"># emmm~ 你细细拼一下这什么意思</span></span><br></pre></td></tr></table></figure>

<p>这个输出表明自实践结束后，还未对目录里的文件进行过任何修改，也没有出现任何处于未跟踪状态的新文件，否则 git 会在这里列出来，最后，该命令还显示了当前所在分支（之后会介绍分支）。</p>
<p>现在，在<code>learngit</code>目录下，新建一个<code>test.txt</code>文件，文件内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is a test file</span><br></pre></td></tr></table></figure>

<p>此时，使用<code>git status</code>命令，就能看到一个新的未被跟踪的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        test.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>在状态报告中可以看到新建的 <code>test.txt</code> 文件出现在 <code>Untracked files</code> 下面。<strong>未跟踪的文件意味着 git 仓库中没有这些文件；git 不会自动将之纳入跟踪范围。</strong>现在搞懂未跟踪文件的意思了吧。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923173631258.png" alt="image-20200923173631258"></p>
<p>如果想要将<code>test.txt</code>也加入git仓库，让git进行管理，就要先将<code>test.txt</code>加入暂存区，进行跟踪。</p>
<p>已经提到很多次暂存区了，那么究竟什么是暂存区？</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923172728086.png" alt="image-20200923172728086"></p>
<h2 id="工作区、暂存区和版本库"><a href="#工作区、暂存区和版本库" class="headerlink" title="工作区、暂存区和版本库"></a>工作区、暂存区和版本库</h2><p><strong>工作区（Working Directory）：</strong></p>
<p>就是在电脑里能看到的目录，比如<code>learngit</code>文件夹就是一个工作区：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923174337765.png" alt="image-20200923174337765"></p>
<p><strong>版本库（Repository）：</strong></p>
<p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923174541512.png" alt="image-20200923174541512"></p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面有讲过使用<code>git add</code>命令将文件加入暂存区，实际上是把要提交的文件的所有修改添加到暂存区，然后执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到本地仓库的分支上。</p>
<p><strong>暂存区（Stage或Index）：</strong></p>
<p>一般存放在 <code>.git</code>目录下的 index 文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（<code>index</code>）。暂存区可以理解为一个虚拟工作区，这个虚拟工作区会跟踪工作区的文件变化（增删改等操作）。这个工作区的位于.git 文件夹下的<code>index</code>文件中。</p>
<p><strong>需要理解一点</strong>：当需要对工作区的修改提交到版本库前，暂存区会与工作区进行差异比较，如果工作区与暂存区的文件不一致，那么需要同步工作区的修改到暂存区，然后才可以提交到版本库。从这个意义讲，暂存区可以说是工作区和版本库的桥梁。好处自然是可以在真正提交到版本库之前做任意的操作，在需要真正提交的时候 commit 到版本库 。当执行完<code>git commit</code>命令时，暂存区会被清空。</p>
<p>实践出真知，我们来实践一下：</p>
<p>在之前的操作中，添加了一个新的文件<code>test.txt</code>，之后就没有其他操作了，现在，我们修改一下<code>readme.txt</code>文件，比如加上一句话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>

<p>再用<code>git status</code>查看一下状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>git非常清楚的告诉了我们，<code>readme.txt</code>被修改了，而<code>test.txt</code>的状态是未被跟踪的。</p>
<p>现在，使用<code>git add</code>命令，把<code>readme.txt</code>和<code>test.txt</code>都添加到暂存区，使用<code>git status</code>再次查看一下状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将readme.txt和test.txt一次性添加到暂存区</span></span><br><span class="line">$ git add readme.txt test.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line">        new file:   test.txt</span><br></pre></td></tr></table></figure>

<p>此时，暂存区的状态就变成这样了：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923183904023.png" alt="image-20200923183904023"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;understand how stage works&#x27;</span></span><br><span class="line">[master 8ec32e3] understand how stage works</span><br><span class="line"> 2 files changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure>

<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923185023250.png" alt="image-20200923185023250"></p>
<p>搞定收工！</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923190158250.png" alt="image-20200923190158250"></p>
<h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><p>使用命令<code>git add</code>开始跟踪一个文件，这个已经讲过很多次了，就不赘述了，不过要注意的是文件名不能写错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里要写文件的全名</span></span><br><span class="line">$ git add test.txt</span><br><span class="line"><span class="comment"># 文件名没有写全，或者写错，会出现下面的信息</span></span><br><span class="line">$ git add <span class="built_in">test</span></span><br><span class="line">fatal: pathspec <span class="string">&#x27;test&#x27;</span> did not match any files</span><br><span class="line">$ git add test.tx</span><br><span class="line">fatal: pathspec <span class="string">&#x27;test.tx&#x27;</span> did not match any files</span><br></pre></td></tr></table></figure>

<h2 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h2><p>暂存已修改的文件，使用的命令是：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923191152796.png" alt="image-20200923191152796"></p>
<p>没错，还是<code>git add</code>，惊不惊喜意不意外？这个前面也已经提到了，就不赘述了。</p>
<p><code>git add</code>命令是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目（仓库）中”要更加合适。</p>
<p><strong>这里有一个需要注意的点：同一个文件，同时出现在暂存区和非暂存区。</strong></p>
<p>我们来重现一下这个问题：</p>
<p>首先，修改<code>readme.txt</code>文件，将内容改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git is so good</span><br></pre></td></tr></table></figure>

<p>使用<code>git add</code>命令将<code>readme.txt</code>放入暂存区，使用<code>git add</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>再次修改<code>readme.txt</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git is so good</span><br><span class="line">Linus is god</span><br></pre></td></tr></table></figure>

<p>此时再次运行<code>git status</code>命令看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>现在<code>readme.txt</code>文件同时出现在暂存区和非暂存区。实际上 git 只不过暂存了你最后一次运行 <code>git add</code> 命令时的版本。 如果你现在提交，你在<code>git add</code> 命令之后的修改，不会被提交到仓库中。 所以，运行了 <code>git add</code> 之后又进行过修改的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>现在把<code>readme.txt</code>提交到仓库吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;update readme.txt&#x27;</span></span><br><span class="line">[master 0086f1a] update readme.txt</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<h2 id="状态简述"><a href="#状态简述" class="headerlink" title="状态简述"></a>状态简述</h2><p><code>git status</code> 命令的输出十分详细，显得有些繁琐。 git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。你可能会看到以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M helloGit.txt</span><br><span class="line">MM README.md</span><br><span class="line">M  test.txt</span><br><span class="line">A  testC.c</span><br><span class="line">?? testDoc.doc</span><br></pre></td></tr></table></figure>

<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>helloGit.txt</code> 文件在工作区已修改但尚未暂存，而 <code>test.txt</code> 文件已修改且已暂存。 <code>README.md</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200918042109655.png" alt="小问号你是否有很多朋友？"></p>
<p>是不是有点晕？没关系，我们再实践一下，重现上面的输出。</p>
<p>上面的输出涉及了5个文件，我们<code>learngit</code>目录中已经有两个了，再新建三个文件<code>app.txt</code>、<code>google.txt</code>、<code>ali.txt</code>，文件内容任意就行。</p>
<ol>
<li><p>将<code>app.txt</code>、<code>google.txt</code>添加到暂存区中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add app.txt google.txt</span><br><span class="line"><span class="comment"># 单独提交 app.txt文件</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;commit app.txt&#x27;</span> app.txt</span><br></pre></td></tr></table></figure>

<p>再修改<code>app.txt</code>文件内容</p>
</li>
<li><p>修改<code>test.txt</code>文件，并使用<code>git add</code>命令将其加入暂存区</p>
</li>
<li><p>修改<code>readme.txt</code>文件，并使用<code>git add</code>命令将其加入暂存区，之后再次进行修改</p>
</li>
<li><p>使用<code>git status -s</code>命令查看状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M app.txt</span><br><span class="line">A  google.txt</span><br><span class="line">MM readme.txt</span><br><span class="line">M  test.txt</span><br><span class="line">?? ali.txt</span><br></pre></td></tr></table></figure>

<p>如果步骤1中没有单独提交<code>app.txt</code>文件，那么输出应该是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">AM app.txt</span><br><span class="line">A  google.txt</span><br><span class="line">MM readme.txt</span><br><span class="line">M  test.txt</span><br><span class="line">?? ali.txt</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>小结：使用<code>git status -s</code>查看状态，状态会以两列显示，左栏表示暂存区的状态，右栏表示工作区的状态。</p>
<p>完美复现了，现在将他们提交到仓库，以免忘记，影响下次实验：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">&#x27;update file content and add app.txt google.txt&#x27;</span></span><br><span class="line">[master b9cb70f] update file content and add app.txt google.txt</span><br><span class="line"> 4 files changed, 7 insertions(+), 2 deletions(-)</span><br><span class="line"> create mode 100644 app.txt</span><br><span class="line"> create mode 100644 google.txt</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>一般来讲，总有不需要放入git仓库进行管理的文件，也不想看到它出现在未跟踪列表，在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore <span class="comment"># cat命令可以查看文件内容</span></span><br><span class="line">*.[oa]	<span class="comment"># 文件内容</span></span><br><span class="line">*~ 		<span class="comment"># 文件内容</span></span><br></pre></td></tr></table></figure>

<p>第一行告诉 git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 git 忽略所有名字以波浪符<code>~</code>结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
<p>我们再看一个 <code>.gitignore</code> 文件的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的 .a 文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任何目录下名为 build 的文件夹</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<p>在最简单的情况下，一个仓库可能只根目录下有一个 <code>.gitignore</code> 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 <code>.gitignore</code> 文件。子目录中的 <code>.gitignore</code> 文件中的规则只作用于它所在的目录中。</p>
<p><strong>Tip：</strong>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表， 你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它。</p>
<p><strong>实践：</strong>在做完上一个示例之后，我们使用<code>git status -s</code>命令查看文件状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        ali.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>git 会一直提示<code>ali.txt</code>未被跟踪，这是不是很烦人，假如这个文件，就是个临时文件，没有价值的文件，我们不想让git管理它，那么，这个时候，我们可以新建一个<code>.gitignore</code>文件，将它加入git仓库进行管理。</p>
<p>首先，新建<code>.gitignore</code>文件。这里说一下，在Windows系统下，是不能直接新建以<code>.</code>开头的文件，除非你这么命名<code>.gitignore.txt</code>（这个是可行的），那么假如你新建的是<code>.gitignore.txt</code>文件，并添加了如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ali.txt</span><br></pre></td></tr></table></figure>

<p>那看看git是怎么看待这个文件的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        .gitignore.txt</span><br><span class="line">        ali.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>没错，就是个普通文件，它并没有让git忽略掉<code>ali.txt</code>文件，那咋办？没错，你可能会想到手动改后缀名呗，那我们来看一下：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925133517166.png" alt="image-20200925133517166"></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925133740607.png" alt="image-20200925133740607"></p>
<p>坑爹的Windows就是不让你改，想砸电脑啊有木有？那可千万别砸，大好几千呢，总有解决问题的方法的。</p>
<p>之前介绍过Notepad++这款软件，这个软件真的超好用，没装的装一下。打开Notepad++，新建文件（中文界面，都是各界精英肯定会），然后在文件中输入一下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ali.txt</span><br></pre></td></tr></table></figure>

<p>没错，就上面一行，然后<code>Ctrl + S</code>保存，这个时候，重点来了（敲黑板）：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925135601734.png" alt="image-20200925135601734"></p>
<p>然后去<code>learngit</code>这个目录下看看，有没有<code>.gitignore</code>文件，接下来就是见证奇迹的时刻：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925135845470.png" alt="image-20200925135845470"></p>
<p><code>.gitignore</code>诞生了，现在来看看git是怎么看待这个文件的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        .gitignore</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>发现没有，<code>ali.txt</code>文件不见了，这说明我们的<code>.gitignore</code>文件生效了，这个时候，我们只需要把<code>.gitignore</code>文件添加到暂存区，然后commit提交到git仓库就行了。当然你不暂存，不提交，都是可以的，它照样可以生效，只是不暂存不提交，你之后每次使用<code>git status</code>命令，都能看见它，你说烦不烦，所以还是乖乖暂存提交吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .gitignore</span><br><span class="line">$ git commit -m <span class="string">&#x27;add file .gitignore &#x27;</span></span><br><span class="line">[master f2e4019] add file .gitignore</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line"><span class="comment"># 在查看一下文件状态 </span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>我们再来看看<code>ali.txt</code>是不是还在我们磁盘上：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925140745067.png" alt="image-20200925140745067"></p>
<p>嗯，还在，说明我真的没有删它，它真的是被git给忽略掉了。OK，示例结束。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925141042753.png" alt="image-20200925141042753"></p>
<p><strong>这里有一个奇葩的需求：</strong>让<code>.gitignore</code>忽略自己，经典的我忽略我自己，可还行。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200918042109655.png" alt="image-20200918042109655"></p>
<p>但是 <code>.gitignore</code> 作为一个仓库结构的一部分，本身就应该是存在的，如果什么都不想忽略，那么就没必要建一个文件了。真碰到这种需求，总归还是要解决的。如果把<code>.gitignore</code>加到<code>.gitignore</code>文件中，是不起作用的。</p>
<p><strong>解决办法：</strong></p>
<p>编辑当前项目下的<code>./git/info/exclude</code>文件，然后将需要忽略提交的<code>.gitignore</code>文件路径写入就行了，注意写入文件的路径是相对项目根目录而言的。</p>
<h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><p>如果你想知道某个文件具体修改了什么地方，可以用 <code>git diff</code> 命令。</p>
<p>现在我们再次修改<code>readme.txt</code>文件后暂存，然后编辑<code>test.txt</code>文件后先不暂存，运行<code>git status</code>命令将会看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   test.txt</span><br></pre></td></tr></table></figure>

<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index 879fceb..9e431f3 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> this is a <span class="built_in">test</span> file</span><br><span class="line">-add some file		<span class="comment"># 前面是-说明是删除的内容</span></span><br><span class="line">\ No newline at end of file <span class="comment"># 在文件末尾没有换行符，这个是编辑器和系统的问题，我没有乱说，我有图为证，后面上Linux下的图</span></span><br><span class="line">+add some file		<span class="comment"># 前面是+说明这是新增的内容 至于为什么先删后加，通过和Linux系统的对比，我认为是系统或者编辑器的问题，如果有知道真相的小伙伴，可以告诉我，帮我纠正一下，共同进步，后面上Linux下的图</span></span><br><span class="line">+<span class="built_in">test</span> git diff		<span class="comment"># 前面是+说明这是新增的内容</span></span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>此命令比较的是修改之后还<strong>没有暂存</strong>起来的变化内容。</p>
<p>想要查看已暂存文件修改了什么内容，可以用<code>git diff --staged</code>命令。这条命令将比对<strong>已暂存文件</strong>与最后一次提交的文件差异：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 7cc6fe7..67386fd 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -4,4 +4,5 @@ Git has a mutable index called stage.</span><br><span class="line"> Git is so good</span><br><span class="line"> Linus is god</span><br><span class="line"> add app.txt file</span><br><span class="line">-add google.txt file</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+add google.txt file</span><br><span class="line">+<span class="built_in">test</span> git diff</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>Linux系统下，同样这两个文件，同样的内容，同样的操作方式：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925145534853.png" alt="image-20200925145534853"></p>
<p>可以看到，只是系统和编辑器不同，Windows多出了几行无关的内容（警告信息），并且出现了先删除后添加的情况，所以我猜测是系统和编辑器的不同造成的，<strong>如果不是，希望知情的小伙伴可以告诉我真正原因！</strong></p>
<p>回归正题，请注意，<code>git diff</code>本身只显示尚<strong>未暂存</strong>的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p>
<p>像之前说的，<strong>暂存</strong> <code>test.txt</code> 后<strong>再修改</strong>（自己随便修改一下），可以使用 <code>git status</code> 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"><span class="comment"># 修改test.txt文件</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   test.txt</span><br></pre></td></tr></table></figure>

<p>这里<code>test.txt</code>出现在了暂存和未暂存的两种状态，现在运行<code>git diff</code>看暂存前后的变化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> test.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory <span class="comment"># 可能会出现警告信息，请忽略它</span></span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index 117f3a6..940c7b0 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> this is a <span class="built_in">test</span> file</span><br><span class="line"> add some file</span><br><span class="line"> <span class="built_in">test</span> git diff</span><br><span class="line">+<span class="comment"># test line</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>git diff --cached</code>查看已经暂存起来的变化（<code>--staged</code>和<code>cached</code>作用是一样的）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line"><span class="comment"># readme.txt</span></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 7cc6fe7..bcb9d8f 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -4,4 +4,5 @@ Git has a mutable index called stage.</span><br><span class="line"> Git is so good</span><br><span class="line"> Linus is god</span><br><span class="line"> add app.txt file</span><br><span class="line">-add google.txt file</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+add google.txt file</span><br><span class="line">+<span class="built_in">test</span> git diff</span><br><span class="line"><span class="comment"># test.txt 重点看这里 是不是没有# test line这一行内容</span></span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index 879fceb..117f3a6 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> this is a <span class="built_in">test</span> file</span><br><span class="line">-add some file</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+add some file</span><br><span class="line">+<span class="built_in">test</span> git diff</span><br></pre></td></tr></table></figure>

<p><strong>这里我们先不提交，因为下面我们就要来讲提交了。</strong></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923165017057.png" alt="你以为这就结束了吗？"></p>
<p>然而并没有！</p>
<p>分析文件差异也可以使用图形化的工具或外部 diff 工具来比较差异，比如DIffMerge，其他工具，自己去找一下。</p>
<p>还可以使用 <code>git difftool</code> 命令来调用 emerge 或 vimdiff 等软件输出 diff 的分析结果。 使用 <code>git difftool --tool-help</code> 命令来看你的系统支持哪些 git Diff 插件。<code>git difftool</code>会依次输出所有文件的分析结果，如果想看某一个文件的diff结果，就加上文件全名，比如：xxx路径下的test.txt，应该写成：<code>git difftool xxx/text.txt</code></p>
<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p>在提交之前，务必确认还有什么已修改或者新建的文件还没有<code>git add</code>过，否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure>

<p>直接运行该命令，会启动你选择的文本编辑器来输入提交说明，如果不输入提交说明，就会提交失败。</p>
<p>编辑器会显示类似下面的文本信息（默认使用的是vim编辑器，可配置自己的编辑器）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span><br><span class="line"><span class="comment"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#       modified:   readme.txt</span></span><br><span class="line"><span class="comment">#       modified:   test.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#       modified:   test.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次提交更新的内容有哪些。</p>
<p>更详细的内容修改提示可以用 <code>git commit -v</code> 查看，这会将你所作的更改的 diff 输出呈现在编辑器中，以便让你知道本次提交具体作出哪些修改。</p>
<p><strong>Tip：</strong>启动的编辑器是通过 Shell 的环境变量 <code>EDITOR</code> 指定的，一般为 vim 或 emacs。 当然也可以 使用 <code>git config --global core.editor</code> 命令设置你喜欢的编辑器。例如：<code>git config --global core.editor vim</code></p>
<p>另外，你也可以在 <code>git commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;commit by xxx&#x27;</span></span><br><span class="line">[master c8731ea] commit by xxx</span><br><span class="line"> 2 files changed, 4 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure>

<p>现在已经进行了一次提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和（<code>c8731ea</code>）是什么，以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<h2 id="跳过使用暂存区提交更新"><a href="#跳过使用暂存区提交更新" class="headerlink" title="跳过使用暂存区提交更新"></a>跳过使用暂存区提交更新</h2><p>git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，git 就会自动把所有<strong>已经跟踪过</strong>的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status <span class="comment"># 查看文件状态 ，可以看到test.txt未被暂存</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"><span class="comment"># 提交未被暂存的文件</span></span><br><span class="line">$ git commit -a -m <span class="string">&#x27;use commit -a -m  command to commit&#x27;</span></span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> test.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">[master d1e9096] use commit -a -m  <span class="built_in">command</span> to commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"><span class="comment"># 再次查看文件状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>提交之前不再需要 <code>git add</code> 文件了。 这是因为 <code>-a</code> 选项使本次提交包含了所有修改过的文件。 <strong>这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。</strong></p>
<h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>要从 git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后<strong>提交</strong>。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <strong>未暂存清单</strong>）看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm test.txt <span class="comment"># 从硬盘中删除test.txt文件，见图</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925172443275.png" alt="image-20200925172443275"></p>
<p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt <span class="comment"># 从暂存区和硬盘中删除test.txt</span></span><br><span class="line">rm <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        deleted:    test.txt</span><br><span class="line"><span class="comment"># 提交，提交之后，上面 deleted 信息就不见了</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;delete test.txt&#x27;</span></span><br><span class="line">[master a8de87f] delete test.txt</span><br><span class="line"> 1 file changed, 4 deletions(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>

<p>提交之后，<code>test.txt</code>文件就不在纳入版本管理，也就是从仓库删除了。如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>（译注：即 force 的首字母），否则会报错。 这是一种安全特性，用于防止误删尚未添加到快照的数据，强制删除的数据不能被 git 恢复。</p>
<p>另外一种情况是，我们想把文件从 git 仓库中删除（或从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm --cached readme.txt</span><br><span class="line">rm <span class="string">&#x27;readme.txt&#x27;</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        deleted:    readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        readme.txt</span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;delete readme.txt from repository and stage&#x27;</span></span><br><span class="line">[master cfef1ea] delete readme.txt from repository and stage</span><br><span class="line"> 1 file changed, 8 deletions(-)</span><br><span class="line"> delete mode 100644 readme.txt</span><br><span class="line"><span class="comment"># 查看文件状态，readme.txt为未跟踪状态，并没有从本地硬盘删除</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        readme.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式（正则表达式）。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm <span class="built_in">log</span>/\*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm \*~</span><br></pre></td></tr></table></figure>

<p>该命令会删除所有名字以 <code>~</code> 结尾的文件。</p>
<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>要在 git 中对文件改名，可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure>

<p>此时查看文件状态信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先修改文件名，比如：把app.txt改为application.txt</span></span><br><span class="line">$ git mv app.txt application.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        renamed:    app.txt -&gt; application.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        readme.txt</span><br><span class="line"><span class="comment"># 记得提交一下</span></span><br><span class="line">$ git commit -m <span class="string">&#x27;rename app.txt -&gt; application.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv app.txt application.txt</span><br><span class="line">$ git rm app.txt</span><br><span class="line">$ git add application.txt</span><br></pre></td></tr></table></figure>

<p>分开操作，git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code> 是一条命令而非三条命令，直接用 <code>git mv</code> 方便得多。 不过有时候用其他工具批处理重命名的话，要记得在提交前删除旧的文件名，再添加新的文件名。</p>
<h1 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h1><p>如果想要查看提交历史，可以使用<code>git log</code>命令。</p>
<p>现在来看看我们学习了这么久，都进行了哪些提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment"># 查看提交历史，这里只贴了部分</span></span><br><span class="line">commit 6a1006ae257767ef55ee588cf9481eb49a369921 (HEAD -&gt; master) <span class="comment"># SHA-1校验和·	1-</span></span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt; <span class="comment"># 作者的名字和邮箱</span></span><br><span class="line">Date:   Fri Sep 25 18:31:06 2020 +0800 <span class="comment"># 提交时间</span></span><br><span class="line"></span><br><span class="line">    rename app.txt -&gt; application.txt <span class="comment"># 提交说明</span></span><br><span class="line"></span><br><span class="line">commit cfef1ea425a67883dba89d4b0d4503cda1648adb</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:18:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete readme.txt from repository and stage</span><br><span class="line"></span><br><span class="line">commit d5051a2d851d6d5e02a4d4d8808f72af42ea38f0</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:10:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete test.txt</span><br><span class="line"></span><br><span class="line">commit d1e9096cdee2ddca0c8213f887e02607d8b88b45</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 16:58:12 2020 +0800</span><br><span class="line"></span><br><span class="line">    use commit -a -m  <span class="built_in">command</span> to commit</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>在不传入任何参数的情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。这个命令会列出每个提交的 SHA-1 校验和作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code> 有许多参数可以选择，<code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出），你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p -2</span><br><span class="line">commit 6a1006ae257767ef55ee588cf9481eb49a369921 (HEAD -&gt; master)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:31:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    rename app.txt -&gt; application.txt</span><br><span class="line"></span><br><span class="line">diff --git a/app.txt b/application.txt</span><br><span class="line">similarity index 100%</span><br><span class="line">rename from app.txt</span><br><span class="line">rename to application.txt</span><br><span class="line"></span><br><span class="line">commit cfef1ea425a67883dba89d4b0d4503cda1648adb</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:18:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete readme.txt from repository and stage</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index bcb9d8f..0000000</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1,8 +0,0 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">-Git is free software.</span><br><span class="line">-Git has a mutable index called stage.</span><br><span class="line">-Git is so good</span><br><span class="line">-Linus is god</span><br><span class="line">-add app.txt file</span><br><span class="line">-add google.txt file</span><br><span class="line">-<span class="built_in">test</span> git diff</span><br></pre></td></tr></table></figure>

<p>该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个同事的提交所带来的变化的时候，这个参数就非常有用了。</p>
<p>如果你想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line">commit 6a1006ae257767ef55ee588cf9481eb49a369921 (HEAD -&gt; master)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:31:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    rename app.txt -&gt; application.txt</span><br><span class="line"></span><br><span class="line"> app.txt =&gt; application.txt | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"></span><br><span class="line">commit cfef1ea425a67883dba89d4b0d4503cda1648adb</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:18:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete readme.txt from repository and stage</span><br><span class="line"></span><br><span class="line"> readme.txt | 8 --------</span><br><span class="line"> 1 file changed, 8 deletions(-)</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line">commit c8731ea86c01c6e9597c14189651df80b1701395</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 16:53:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    commit by xxx</span><br><span class="line"><span class="comment"># 被修改的文件  受影响的行数   	 +表示添加，-表示删除，符号个数表示添加或删除了多少行</span></span><br><span class="line"> readme.txt |    3 				++-</span><br><span class="line"> test.txt   |    3 				++-</span><br><span class="line"> 2 files changed, 4 insertions(+), 2 deletions(-) <span class="comment"># 总结</span></span><br></pre></td></tr></table></figure>

<p><code>--stat</code> 参数在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p>
<p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">6a1006ae257767ef55ee588cf9481eb49a369921 (HEAD -&gt; master) rename app.txt -&gt; application.txt</span><br><span class="line">cfef1ea425a67883dba89d4b0d4503cda1648adb delete readme.txt from repository and stage</span><br><span class="line">d5051a2d851d6d5e02a4d4d8808f72af42ea38f0 delete test.txt</span><br><span class="line">d1e9096cdee2ddca0c8213f887e02607d8b88b45 use commit -a -m  <span class="built_in">command</span> to commit</span><br><span class="line">c8731ea86c01c6e9597c14189651df80b1701395 commit by xxx</span><br><span class="line">f2e4019f887c78efefb9e33939fe9fa9fe10a4da add file .gitignore</span><br><span class="line">b9cb70fb52a212cd017a4d62b6ed60d434d79fa5 update file content and add app.txt google.txt</span><br><span class="line">0086f1a9f1f1152ec52aa9f526e870b0618138a3 update readme.txt</span><br><span class="line">8ec32e3bc32518befcb10740cd6e58dd6c5f7a96 understand how stage works</span><br><span class="line">d1bdde3d4757173c06ed6cf4ac005c39c00ddf58 write a readme file</span><br></pre></td></tr></table></figure>

<p>如果你想定制记录的显示格式，可以使用<code>format</code>，这样的输出对后期提取分析格外有用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span><br><span class="line">6a1006a - hahaha, 63 minutes ago : rename app.txt -&gt; application.txt</span><br><span class="line">cfef1ea - hahaha, 76 minutes ago : delete readme.txt from repository and stage</span><br><span class="line">d5051a2 - hahaha, 84 minutes ago : delete test.txt</span><br><span class="line">d1e9096 - hahaha, 3 hours ago : use commit -a -m  <span class="built_in">command</span> to commit</span><br><span class="line">c8731ea - hahaha, 3 hours ago : commit by xxx</span><br><span class="line">f2e4019 - hahaha, 5 hours ago : add file .gitignore</span><br><span class="line">b9cb70f - hahaha, 7 hours ago : update file content and add app.txt google.txt</span><br><span class="line">0086f1a - hahaha, 2 days ago : update readme.txt</span><br><span class="line">8ec32e3 - hahaha, 2 days ago : understand how stage works</span><br><span class="line">d1bdde3 - hahaha, 2 days ago : write a readme file</span><br></pre></td></tr></table></figure>

<p><code>git log --pretty=format</code> 接受的常用格式占位符的写法及其代表的意义：</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%H</code></td>
<td align="left">提交的完整哈希值</td>
</tr>
<tr>
<td align="left"><code>%h</code></td>
<td align="left">提交的简写哈希值</td>
</tr>
<tr>
<td align="left"><code>%T</code></td>
<td align="left">树的完整哈希值</td>
</tr>
<tr>
<td align="left"><code>%t</code></td>
<td align="left">树的简写哈希值</td>
</tr>
<tr>
<td align="left"><code>%P</code></td>
<td align="left">父提交的完整哈希值</td>
</tr>
<tr>
<td align="left"><code>%p</code></td>
<td align="left">父提交的简写哈希值</td>
</tr>
<tr>
<td align="left"><code>%an</code></td>
<td align="left">作者名字</td>
</tr>
<tr>
<td align="left"><code>%ae</code></td>
<td align="left">作者的电子邮件地址</td>
</tr>
<tr>
<td align="left"><code>%ad</code></td>
<td align="left">作者修订日期（可以用 –date=选项 来定制格式）</td>
</tr>
<tr>
<td align="left"><code>%ar</code></td>
<td align="left">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td align="left"><code>%cn</code></td>
<td align="left">提交者的名字</td>
</tr>
<tr>
<td align="left"><code>%ce</code></td>
<td align="left">提交者的电子邮件地址</td>
</tr>
<tr>
<td align="left"><code>%cd</code></td>
<td align="left">提交日期</td>
</tr>
<tr>
<td align="left"><code>%cr</code></td>
<td align="left">提交日期（距今多长时间）</td>
</tr>
<tr>
<td align="left"><code>%s</code></td>
<td align="left">提交说明</td>
</tr>
</tbody></table>
<p><strong>作者和提交者的区别：</strong></p>
<p>作者：实际对项目做出修改的人</p>
<p>提交者：将作者对项目做出的修改提交的仓库的人，更多时候，作者和提交者都为同一人。</p>
<p>当 <code>oneline</code> 或 <code>format</code> 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=formt:<span class="string">&quot;%h %s&quot;</span> --graph <span class="comment"># 还没有将分支，所以这个看不到效果，之后将分支时再演示</span></span><br></pre></td></tr></table></figure>

<p><code>git log</code> 的常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code></td>
<td>按补丁格式显示每个提交引入的差异。</td>
</tr>
<tr>
<td><code>--stat</code></td>
<td>显示每次提交的文件修改统计信息。</td>
</tr>
<tr>
<td><code>--shortstat</code></td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td><code>--name-only</code></td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td><code>--name-status</code></td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td><code>--abbrev-commit</code></td>
<td>仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td>
</tr>
<tr>
<td><code>--relative-date</code></td>
<td>使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</td>
</tr>
<tr>
<td><code>--graph</code></td>
<td>在日志旁以 ASCII 图形显示分支与合并历史。</td>
</tr>
<tr>
<td><code>--pretty</code></td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</td>
</tr>
<tr>
<td><code>--oneline</code></td>
<td><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</td>
</tr>
</tbody></table>
<h2 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h2><p>我们可以使用<code>-&lt;n&gt;</code>选项限制输出长度，其中<code>n</code>可以是任何整数，表示显示最近的<code>n</code>条提交，例如前面提到的<code>-2</code>，显示最近的两条提交。不过这个不是很实用，如果输入的数字过大，git默认会自动分页，所以一次也就只能看到一页的内容。</p>
<p>但是，类似 <code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近一周的所有提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --since=1.weeks <span class="comment"># 最近一周的所有提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --since=<span class="string">&quot;1 day ago&quot;</span>  <span class="comment"># 一天前的提交，下面是一天前的提交</span></span><br><span class="line">commit 6a1006ae257767ef55ee588cf9481eb49a369921 (HEAD -&gt; master)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:31:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    rename app.txt -&gt; application.txt</span><br><span class="line"></span><br><span class="line">commit cfef1ea425a67883dba89d4b0d4503cda1648adb</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:18:22 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete readme.txt from repository and stage</span><br><span class="line"></span><br><span class="line">commit d5051a2d851d6d5e02a4d4d8808f72af42ea38f0</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:10:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete test.txt</span><br><span class="line"></span><br><span class="line">commit d1e9096cdee2ddca0c8213f887e02607d8b88b45</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 16:58:12 2020 +0800</span><br><span class="line"></span><br><span class="line">    use commit -a -m  <span class="built_in">command</span> to commit</span><br><span class="line"></span><br><span class="line">commit c8731ea86c01c6e9597c14189651df80b1701395</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 16:53:37 2020 +0800</span><br><span class="line"></span><br><span class="line">    commit by xxx</span><br></pre></td></tr></table></figure>

<p>该命令可用的格式十分丰富——可以是类似 <code>&quot;2020-01-15&quot;</code> 的具体的某一天，也可以是类似 <code>&quot;1 years 1 day 3 minutes ago&quot;</code> 的相对日期。</p>
<p>还可以过滤出匹配指定条件的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --author=<span class="string">&quot;hehehe&quot;</span> --grep=<span class="string">&quot;rename&quot;</span> <span class="comment"># 查看用户名为&quot;hahaha&quot; 并且 提交说明中有rename关键字的提交</span></span><br><span class="line">commit 6a1006ae257767ef55ee588cf9481eb49a369921 (HEAD -&gt; master)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 25 18:31:06 2020 +0800</span><br><span class="line"></span><br><span class="line">    rename app.txt -&gt; application.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你可以指定多个 <code>--author</code> 和 <code>--grep</code> 搜索条件，这样会只输出 <strong>任意</strong> 匹配 <code>--author</code> 模式和 <code>--grep</code> 模式的提交。然而，如果你添加了 <code>--all-match</code> 选项， 则只会输出 <strong>所有</strong> 匹配 <code>--grep</code> 模式的提交。</p>
</blockquote>
<p>另一个非常有用的过滤器是 <code>-S</code>， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -S function_name</span><br></pre></td></tr></table></figure>

<p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -- app.txt <span class="comment"># 查看app.txt的相关提交，如果是在某个文件夹下，应该写成git log -- xxx/app.txt</span></span><br></pre></td></tr></table></figure>

<p><code>git log</code>的选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-&lt;n&gt;</code></td>
<td>仅显示最近的 n 条提交。</td>
</tr>
<tr>
<td><code>--since</code>, <code>--after</code></td>
<td>仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td><code>--until</code>, <code>--before</code></td>
<td>仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td><code>--author</code></td>
<td>仅显示作者匹配指定字符串的提交。</td>
</tr>
<tr>
<td><code>--committer</code></td>
<td>仅显示提交者匹配指定字符串的提交。</td>
</tr>
<tr>
<td><code>--grep</code></td>
<td>仅显示提交说明中包含指定字符串的提交。</td>
</tr>
<tr>
<td><code>-S</code></td>
<td>仅显示添加或删除内容匹配指定字符串的提交。</td>
</tr>
</tbody></table>
<blockquote>
<p>隐藏合并提交：<br>按照你代码仓库的工作流程，记录中可能有为数不少的合并提交，它们所包含的信息通常并不多。 为了避免显示的合并提交弄乱历史记录，可以为 <code>log</code> 加上 <code>--no-merges</code> 选项。</p>
</blockquote>
<h1 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h1><h2 id="修补提交"><a href="#修补提交" class="headerlink" title="修补提交"></a>修补提交</h2><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>执行这个命令，文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p>
<p>例如，你提交之后，发现忘记暂存某些需要的修改，可以向下面这样操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;提交信息&#x27;</span></span><br><span class="line">$ git add forgotten_file <span class="comment"># 添加漏掉的暂存文件</span></span><br><span class="line">$ git commit --amend <span class="comment"># 可以修改提交信息然后重新提交</span></span><br></pre></td></tr></table></figure>

<p>最终你只会有一个提交记录——第二次提交将代替第一次提交的结果。</p>
<p>这个操作最主要的还是修改<strong>提交信息</strong>，以免自己的仓库被提交信息弄乱了历史版本。</p>
<p><strong>实战：</strong></p>
<p>在之前的示例中，我们把readme.txt从仓库中删除之后，一直没有再添加到仓库中，现在正好用这个例子重新加入仓库。</p>
<p>先修改<code>google.txt</code>文件，使用<code>git add</code>加入暂存区，查看文件状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   google.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        readme.txt</span><br></pre></td></tr></table></figure>

<p>使用<code>git commit</code>提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;modify google.txt&#x27;</span></span><br><span class="line">[master acf1451] modify google.txt</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>将<code>readme.txt</code>加入暂存区，然后使用<code>git commit --amend</code>命令，可以看到上次的提交信息：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200926153221487.png" alt="image-20200926153221487"></p>
<p>修改提交信息，输入法为英文状态下，按<code>i</code>键，光标移到末尾修改提交内容，修改完成后，同样英文状态下，按下<code>ESC</code>，然后输入<code>:</code>，接着输入<code>wq</code>保存退出，即可看到提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br><span class="line">[master 73d5592] modify google.txt and add file readme.txt</span><br><span class="line"> Date: Sat Sep 26 15:36:23 2020 +0800</span><br><span class="line"> 2 files changed, 10 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>

<p>查看最近一次的提交历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit 73d5592122fe5442f7c8a0398c44c1eda9ade985 (HEAD -&gt; master)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Sat Sep 26 15:36:23 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify google.txt and add file readme.txt</span><br></pre></td></tr></table></figure>

<h2 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h2><p>如果手抖，把本想分为两次独立提交的文件使用<code>git add *</code>全部加入了暂存区，可以使用<code>git reset HEAD &lt;file&gt;</code>或者<code>git restore --staged &lt;file&gt;</code> 来取消暂存，<code>git status</code>命令其实也给出了提示：</p>
<p>我们再修改下<code>readme.txt</code>文件，然后暂存，使用<code>git status</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>取消暂存的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git restore --staged readme.txt</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br><span class="line"><span class="comment"># 查看状态，可以看到readme.txt又处于为暂存状态了</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>git reset</code>命令更多的用于回退版本（稍后讲），所以只是想取消暂存的文件，建议使用<code>git restore --staged &lt;file&gt;</code>命令</p>
<h2 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h2><p>如果文件被改的一团糟了，这个时候想撤销全部更改，你可以使用<code>git restore &lt;file&gt;</code>来撤销更改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如，我想撤销刚才readme.txt的更改</span></span><br><span class="line">$ git restore readme.txt</span><br></pre></td></tr></table></figure>

<p>此时查看文件内容，你会发现你所有的修改都被撤销了</p>
<p>在 git 中还可以使用<code>git checkout -- &lt;file&gt;</code>命令撤销对文件的修改，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;test checkout -- command&#x27;</span> &gt;&gt; readme.txt <span class="comment"># 对readme.txt文件追加内容</span></span><br><span class="line">$ git checkout -- readme.txt <span class="comment"># 撤销修改</span></span><br></pre></td></tr></table></figure>

<p>使用<code>git checkout -- &lt;file&gt;</code>命令撤销修改，其实是 git 使用了最近提交的版本覆盖了它，<code>git checkout</code>命令还有其他用途，稍有不慎，就会造成意外情况，所以慎用。</p>
<p><strong>推荐使用<code>git restore &lt;file&gt;</code>命令来撤销修改，毕竟git自己推荐的</strong></p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>讲这个之前，我们先进行3次提交，例如：</p>
<p>第一次修改<code>readme.txt</code>文件，添加内容<code>add version 1.0</code>，然后提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">&#x27;readme.txt version 1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第二次修改<code>readme.txt</code>文件，添加内容<code>add version 2.0</code>，然后提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">&#x27;readme.txt version 2.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第三次修改<code>readme.txt</code>文件，添加内容<code>add version 3.0</code>，然后提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">&#x27;readme.txt version 3.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在来看看最近四次的提交历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline -4</span><br><span class="line"><span class="comment"># commitID（可以简单的理解为版本号）           提交说明</span></span><br><span class="line">0b1cde03e2ec38c4d43c090fa1d709894eb441a2 (HEAD -&gt; master) readme.txt version 3.0</span><br><span class="line">4b4566931f544da69ee1d6ef9d5c26af7e8108d8 readme.txt version 2.0</span><br><span class="line">d3c72dd5ba02000c359d3b7b524250f42d3fade5 readme.txt version 1.0</span><br><span class="line">73d5592122fe5442f7c8a0398c44c1eda9ade985 modify google.txt and add file readme.txt</span><br></pre></td></tr></table></figure>

<p>如果现在我们要回退一个版本，也就是说，我现在需要回到<code>readme.txt version 2.0</code>这个版本，就可以使用<code>git reset --hard HEAD^</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 4b45669 readme.txt version 2.0</span><br><span class="line"><span class="comment"># 查看提交历史： 可以发现readme.txt version 3.0已经不见了</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline -4</span><br><span class="line">4b4566931f544da69ee1d6ef9d5c26af7e8108d8 (HEAD -&gt; master) readme.txt version 2.0</span><br><span class="line">d3c72dd5ba02000c359d3b7b524250f42d3fade5 readme.txt version 1.0</span><br><span class="line">73d5592122fe5442f7c8a0398c44c1eda9ade985 modify google.txt and add file readme.txt</span><br><span class="line">6a1006ae257767ef55ee588cf9481eb49a369921 rename app.txt -&gt; application.txt</span><br><span class="line"><span class="comment"># 查看readme.txt文件内容，之前添加的add version 3.0 也不见了，也就是说“时光倒流了”，版本确实回退了</span></span><br><span class="line">$ cat readme.txt</span><br><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git is so good</span><br><span class="line">Linus is god</span><br><span class="line">add app.txt file</span><br><span class="line">add google.txt file</span><br><span class="line"><span class="built_in">test</span> git diff</span><br><span class="line">add version 1.0</span><br><span class="line">add version 2.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HEAD在git中是一个特殊的指针，指向当前所在的本地分支，这里只有一个<code>master</code>分支，所以它指向的就是<code>master</code>分支，在上面的提交历史也可一看到HEAD指向的是谁(HEAD -&gt; master)。不理解没关系，后面分支还会讲到。</p>
</blockquote>
<p><code>HEAD^</code>表示的是上一个版本，那么上上一个版本呢？可以写成<code>HEAD^^</code>，那么要回到上10个版本怎么办？总不能写10个<code>^</code>吧，其实可以写成这个<code>HEAD~10</code>。当然如果要回退很多个版本，自己手动数是不可取的，这个时候，<code>commitId</code>的作用就体现出来了，比如现在我们要回退到<code>readme.txt version 1.0</code>这个版本，我们可以使用<code>git reset --hard &lt;commitId&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard d3c72dd</span><br><span class="line">HEAD is now at d3c72dd readme.txt version 1.0</span><br><span class="line"><span class="comment"># 查看 readme.txt 内容 版本回退成功</span></span><br><span class="line">$ cat readme.txt</span><br><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git is so good</span><br><span class="line">Linus is god</span><br><span class="line">add app.txt file</span><br><span class="line">add google.txt file</span><br><span class="line"><span class="built_in">test</span> git diff</span><br><span class="line">add version 1.0</span><br></pre></td></tr></table></figure>

<p>我们在使用<code>commitId</code>时，可以不必要写完整的<code>commitId</code>，通常使用<code>8~10</code>个字符就可以精确指定到某个版本，如果怕产生歧义，就多写几位。</p>
<p>现在版本是回退成功了，那如果手抖，回退版本时，退的太多了怎么办？或者说，后悔了，想回到未来的某个版本怎么办，现在使用<code>git log</code>也看不到回退前的<code>commitId</code>了。<strong>那么我告诉你，这个世界上是没有后悔药的。</strong></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200926181856685.png" alt="image-20200926181856685"></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200926182357354.png" alt="image-20200926182357354"></p>
<p>其他事不存在后悔药，但是git是有后悔药吃的。</p>
<p>git在后台会保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p>
<p>你可以使用 <code>git reflog</code> 来查看引用日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">d3c72dd (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to d3c72dd</span><br><span class="line">4b45669 HEAD@&#123;1&#125;: reset: moving to head^</span><br><span class="line">0b1cde0 HEAD@&#123;2&#125;: commit: readme.txt version 3.0</span><br><span class="line">4b45669 HEAD@&#123;3&#125;: commit: readme.txt version 2.0</span><br><span class="line">d3c72dd (HEAD -&gt; master) HEAD@&#123;4&#125;: commit: readme.txt version 1.0</span><br><span class="line">73d5592 HEAD@&#123;5&#125;: commit (amend): modify google.txt and add file readme.txt</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>通过这个日志，我们可以拿到我们回退前的<code>commitId</code>。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200925133740607.png" alt="惊不惊喜意不意外"></p>
<p>那现在，我们可以回到“未来”去了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 0b1cde0</span><br><span class="line">HEAD is now at 0b1cde0 readme.txt version 3.0</span><br><span class="line"><span class="comment">#查看readme.txt 文件内容</span></span><br><span class="line">$ cat readme.txt</span><br><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git is so good</span><br><span class="line">Linus is god</span><br><span class="line">add app.txt file</span><br><span class="line">add google.txt file</span><br><span class="line"><span class="built_in">test</span> git diff</span><br><span class="line">add version 1.0</span><br><span class="line">add version 2.0</span><br><span class="line">add version 3.0</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200926184617424.png" alt="image-20200926184617424"></p>
<h1 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h1><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上，这个服务器可以是自己搭建的，如果不想自己搭建，那么我们就是用<a href="https://github.com/">GitHub</a>吧，或者使用<a href="https://gitee.com/">码云</a>。</p>
<p>GitHub和码云的操作都大同小异，这里就以GitHub为例。</p>
<p>‘’ Github 是目前全球最大的同性（主要是男性）交友平台. ‘’ ———– 来自知乎</p>
<p>Github是一个基于git的代码托管平台，个人用户目前可以免费使用公共仓库和私有仓库，公共仓库对所有人可见，私有仓库仅对自己以及你邀请的协作者可见 !</p>
<p>开发者可以将代码在 GitHub 上开源，可以浏览其它项目的代码，fork 到自己名下做修改，clone 回本地（没有访问权限的 private repo 除外）使用，也可以发起 pull request 向上游提交自己的修改。GitHub 围绕项目（即 Git 中的 Repository）做了许多功能，例如 Wiki，首页（GitHub Pages）等，也可以通过 Graph 来查看其他人 fork 的情况。GitHub 也有 Gists，用于分享代码片段。除此之外也有许多包管理器以 GitHub 作为包仓库 </p>
<h2 id="注册GitHub账户"><a href="#注册GitHub账户" class="headerlink" title="注册GitHub账户"></a>注册GitHub账户</h2><p>请前往官网：<a href="https://github.com/">https://github.com/</a> 进行注册，注册账号我就不介绍，太简单了。</p>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>创建好GitHub账户，现在来创建一个新的仓库：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200927102143086.png" alt="image-20200927102143086"></p>
<p>点击了<code>CREATE repository</code>按钮之后，就成功地创建了一个新的git仓库：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200927102703841.png" alt="image-20200927102703841"></p>
<p>目前，这个在GitHub上的<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>GitHub SSH配置可参考<a href="https://tiangoubot.github.io/2020/10/01/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/">教程</a></p>
<h2 id="添加与查看远程仓库"><a href="#添加与查看远程仓库" class="headerlink" title="添加与查看远程仓库"></a>添加与查看远程仓库</h2><p>现在我们创建的远程仓库还没有内容，我们要把本地<code>learngit</code>（本地仓库名和远程仓库名可以不一致）代码推送到远程仓库上去，该怎么办呢？</p>
<p>首先，我们需要添加远程仓库，使用<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>命令，现在根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/tiangoubot/learngit.git</span><br></pre></td></tr></table></figure>

<p>请注意，把上面的<code>tiangoubot</code>替换成你自己的GitHub账户名，否则你本地关联的就是我的远程库了。</p>
<p>添加后，远程仓库的名字就是<code>origin</code>，这是git默认的叫法，可以修改成别的。</p>
<p><strong>Tip：如果你使用<code>git clone</code>命令克隆了一个仓库，这个命令会自行添加远程仓库，默认名字就是<code>origin</code></strong></p>
<p>我们添加完了远程仓库，如果你想查看一下远程仓库，你可以使用<code>git remote</code>命令，你也可以使用<code>git remote -v</code>命令，该命令会显示读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin <span class="comment"># 只显示默认的远程仓库名</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/tiangoubot/learngit.git (fetch)</span><br><span class="line">origin  https://github.com/tiangoubot/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>如果你的远程仓库不止一个，该命令会将它们全部列出。</p>
<h2 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h2><p>如果你已经添加了远程仓库，想要从远程仓库中获取数据，可以称为抓取或者拉取数据，可以使用该命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;remote&gt;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git pull &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>那么这两个命令有什么区别？</p>
<p><code>git fetch</code>命令会访问远程仓库，从中拉取你本地没有的数据。执行完成后，将会用有哪个远程仓库中所有分支的引用，可以随时合并或查看（分支不懂没关系，稍后会介绍），也就是说，这个命令只会把你没有的数据拉取下来，然后就放那里了，你需要手动合并这些数据，如果有冲突，你需要解决这些冲突之后才能进行合并。</p>
<p><code>git pull</code>命令同样也会访问远程仓库，它会把远程仓库中最新版本的数据拉取下来，然后合并该远程分支到当前分支。也就是说，不管你本地的数据是否进行过修改，也不管是否和远程仓库中的代码有没有冲突，只要是你本地没有的数据，通通拉取下来，然后自动合并数据，有冲突会议远程仓库数据为准进行覆盖。如果这个时候，你对某个文件进行了修改，准备先同步数据再进行提交，然而远程仓库上，有人已经对这个文件进行了修改，你们产生了冲突，你使用了改命令进行拉取数据，那么你的修改，就会被覆盖掉，那你就前功尽弃了。</p>
<p>所以<code>git pull</code>一定要慎用，以免出现不必要的麻烦，推荐使用<code>git fetch</code>，至于怎么合并数据，在分支中会讲</p>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好<code>master</code>和<code>origin</code>这两个名字）， 那么运行<code>git push &lt;remote&gt; &lt;brance&gt;</code>这个命令就可以将你的本地代码推送到服务器。</p>
<p>如果你之前没有推送过代码到GitHub上，那你会看到这个弹窗：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200927125150725.png" alt="image-20200927125150725"></p>
<p>输入自己的GitHub账号密码，登录就行了，你输入账号密码之后，Windows会自动记录你的账号密码，下次就不用再输入了。之后使用下面的命令进行推送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line">Enumerating objects: 44, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (44/44), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (36/36), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (44/44), 3.48 KiB | 127.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 44 (delta 16), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (16/16), <span class="keyword">done</span>.</span><br><span class="line">To https://github.com/tiangoubot/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>如果你使用<code>git clone</code>命令，克隆了一个远程仓库，这时候你想要推送自己的代码，那么， 你必须拥有你所克隆服务器的写入权限，并且在你之前没有人进行过推送，这条命名才能生效。</p>
<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200927130408503.png" alt="image-20200927130408503"></p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><p>想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的仓库名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/tiangoubot/learngit.git</span><br><span class="line">  Push  URL: https://github.com/tiangoubot/learngit.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>

<p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地（如果有会列出，这里没有），哪些远程分支已经从服务器上移除了（如果有会列出，这里没有）， 还有当你执行 <code>git pull</code> 时哪些本地分支可以与它跟踪的远程分支自动合并。</p>
<h2 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h2><p>使用 <code>git remote rename</code> 可以修改一个远程仓库的简写名。 例如，想要将 <code>origin</code> 重命名为 <code>learngit</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rename origin learngit</span><br><span class="line">$ git remote  -v</span><br><span class="line">learngit        https://github.com/tiangoubot/learngit.git (fetch)</span><br><span class="line">learngit        https://github.com/tiangoubot/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>origin/master</code> 的现在会引用 <code>learngit/master</code>。</p>
<p>使用 <code>git remote remove</code> 或 <code>git remote rm</code> 命令可以移除一个远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote remove learngit</span><br></pre></td></tr></table></figure>

<p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>标签，顾名思义就是做标记，在git中，一般用与标记某个发布节点。</p>
<p>git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p><strong>轻量标签：</strong>很像一个不会改变的分支——它只是某个特定提交的引用，不会存储任何信息。</p>
<p><strong>附注标签：</strong>是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 </p>
<p>通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p>
<h2 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h2><p>使用<code>git tag</code>命令（可带上可选的参数<code>-l</code>或者<code>-list</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure>

<p>这个命令会以字母顺序列出标签，但不是很重要</p>
<p>如果对某个特定的版本号感兴趣，可以使用下面的方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -l <span class="string">&quot;v1.8.5*&quot;</span> <span class="comment"># 查看v1.8.5系列</span></span><br></pre></td></tr></table></figure>

<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p><strong>附注标签：</strong></p>
<p>在 git 中创建附注标签十分简单。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.0 -m <span class="string">&#x27;test version 1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，git 会启动编辑器要求你输入信息。</p>
<p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git show -q v1.0 <span class="comment"># -q表示不显示差异输出</span></span><br><span class="line">tag v1.0</span><br><span class="line">Tagger: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Sun Sep 27 14:21:53 2020 +0800</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> version 1.0</span><br><span class="line"></span><br><span class="line">commit 6680bd40434821abf3e29045593629d4c9fddb15 (HEAD -&gt; master, tag: v1.0)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Sun Sep 27 12:58:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify google.txt add google play</span><br></pre></td></tr></table></figure>

<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<p><strong>轻量标签：</strong></p>
<p>轻量标签本质上是将提交校验和 存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag v1.0.1</span><br></pre></td></tr></table></figure>

<p>这时，如果运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git show -q v1.0.1</span><br><span class="line">commit 6680bd40434821abf3e29045593629d4c9fddb15 (HEAD -&gt; master, tag: v1.0.1, tag: v1.0)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Sun Sep 27 12:58:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify google.txt add google play</span><br></pre></td></tr></table></figure>

<h2 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h2><p>git也可以对过去的提交打标签。假如提交历史是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">6680bd4 (HEAD -&gt; master, tag: v1.0.1, tag: v1.0) modify google.txt add google play</span><br><span class="line">0b1cde0 readme.txt version 3.0</span><br><span class="line">4b45669 readme.txt version 2.0</span><br><span class="line">d3c72dd readme.txt version 1.0</span><br><span class="line">73d5592 modify google.txt and add file readme.txt</span><br><span class="line">6a1006a rename app.txt -&gt; application.txt</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>假设现在想在<code>readme.txt version 1.0</code>这次提交上打个标签，那么就需要在命令的末尾指定提交的校验和（或部分校验和）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.0-release d3c72dd -m <span class="string">&#x27;后期打标签，释放1.0版本&#x27;</span></span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.0-release</span><br><span class="line">v1.0.1</span><br><span class="line"></span><br><span class="line">$ git show -q v1.0-release</span><br><span class="line">tag v1.0-release</span><br><span class="line">Tagger: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Sun Sep 27 14:31:55 2020 +0800</span><br><span class="line"></span><br><span class="line">后期打标签，释放1.0版本</span><br><span class="line"></span><br><span class="line">commit d3c72dd5ba02000c359d3b7b524250f42d3fade5 (tag: v1.0-release)</span><br><span class="line">Author: hahaha &lt;orcale.io@gmail.com&gt;</span><br><span class="line">Date:   Sat Sep 26 16:56:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    readme.txt version 1.0</span><br></pre></td></tr></table></figure>

<p>可以看到你已经在那次提交上打上标签了。</p>
<h2 id="共享（推送）标签"><a href="#共享（推送）标签" class="headerlink" title="共享（推送）标签"></a>共享（推送）标签</h2><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin &lt;tagname&gt;</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在之前讲远程仓库时，我们在最后把远程仓库移除了，现在我们先添加上</span></span><br><span class="line">$ git remote add origin https://github.com/tiangoubot/learngit.git</span><br><span class="line"><span class="comment"># 共享（推送）标签到远程仓库</span></span><br><span class="line">$ git push origin v1.0-release</span><br><span class="line">Enumerating objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 201 bytes | 50.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/tiangoubot/learngit.git</span><br><span class="line"> * [new tag]         v1.0-release -&gt; v1.0-release</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200927143930833.png" alt="image-20200927143930833"></p>
<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Enumerating objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 160.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/tiangoubot/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br><span class="line"> * [new tag]         v1.0.1 -&gt; v1.0.1</span><br></pre></td></tr></table></figure>

<p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p>
<h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><p>删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。 例如，可以使用以下命令删除一个轻量标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -d v1.0.1</span><br><span class="line">Deleted tag <span class="string">&#x27;v1.0.1&#x27;</span> (was 6680bd4)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>上述命令并不会从任何远程仓库中移除这个标签，你必须使用下面的方式来更新你的远程仓库。</p>
<ul>
<li><p>方式一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v1.0.1</span><br><span class="line">To https://github.com/tiangoubot/learngit.git</span><br><span class="line"> - [deleted]         v1.0.1</span><br></pre></td></tr></table></figure>

<p>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。</p>
</li>
<li><p>方式二（更直观一点）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete v1.0</span><br><span class="line">To https://github.com/tiangoubot/learngit.git</span><br><span class="line"> - [deleted]         v1.0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h2><p>我还没弄明白，先空着，以后搞清楚了再来更新！</p>
<h1 id="别名（了解）"><a href="#别名（了解）" class="headerlink" title="别名（了解）"></a>别名（了解）</h1><p> git 旧版本并不会在你输入部分命令时自动补全你想要的命令，如果不想每次都输入完整的git命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure>

<p>新版本的git有自动补全命令的功能，建议比较长的命令可以使用别名，比如查看提交历史的。</p>
<p>更多的信息，请查看git官网</p>
<h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>什么是Git分支？</p>
<p>看看git官网是怎么说的，有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出……吧啦吧啦说了一大堆，看得是一脸懵逼。</p>
<p><strong>简单的说，分支就是火影忍者中的影分身之术，可以从本体分出好多个分身，本体可以看做是主干，分身可以看做为主干的分支，能够同时独立的工作，也可以在需要的时候合为一体。不知道火影忍者的，可以参考孙悟空，他也会分身。</strong></p>
<p>这只是简单的打个比方，很多版本控制系统支持分支，唯独 git 的分支模型独领风骚，那么 git 是的分支是如何实现的？</p>
<p>接下来会用图文并茂（文字也请认真看，让自己有个印象）的方式来帮你理解git分支以及它的强大之处。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923094752490.png" alt="我要开始装逼了"></p>
<p>git 保存数据，保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>快照</strong>。在进行提交操作时，git 会保存一个提交对象（commit object）。知道了 git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用SHA-1 哈希算法），然后会把当前版本的文件快照保存到 git 仓库中 （git 使用 <em>blob</em> 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m <span class="string">&#x27;The initial commit of my project&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当使用 <code>git commit</code> 进行提交操作时，git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 git 仓库中这些校验和保存为树对象。随后，git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，git 就可以在需要的时候重现此次保存的快照。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200918042109655.png" alt="这啥玩意儿？"></p>
<p>别方，现在我们来看看首次提交对象及其树结构：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200920221304154.png" alt="image-20200920221304154"></p>
<p>现在，git 仓库中有五个对象：三个 <em>blob</em> 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向树对象的指针和所有提交信息）。</p>
<p><strong>注：</strong>这里为什么是三个<em>blob</em>对象，是因为前面我们用的<code>git add README test.rb LICENSE</code>命令暂存了这三个文件，随后就提交了，所以产生了三个blob对象。</p>
<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200920223441356.png" alt="image-20200920223441356"></p>
<p>git 的分支，其实本质上仅仅是指向提交对象的可变指针。 git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 <code>master</code> 分支会在每次提交时自动向前移动。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200920232041377.png" alt="image-20200920232041377"></p>
<p><strong>注：git 的 <code>master</code> 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它</strong>。</p>
<p><strong>今年，也就是2020年10月1日起，所有在GitHub上新建的仓库默认名字都将改为<code>main</code>而不是<code>master</code>。此前的所有仓库不受影响</strong></p>
<h2 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h2><p>git 创建一个分支，只是为你创建了一个可以移动的新的指针，比如，创建一个testing分支，你需要使用<code>git branch</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>

<p>通常我们会在创建一个新分支后立即切换过去，这可以用 <code>git checkout -b &lt;newbranchname&gt;</code> 一条命令搞定。</p>
<p>这会在当前所在的提交对象上创建一个指针。两个指向相同提交历史的分支：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200920233111213.png" alt="image-20200920233111213"></p>
<p>那么，git 又是怎么知道当前在哪一个分支上的？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 git 中，它是一个指针，指向当前所在的本地分支，可以将 <code>HEAD</code> 想象为当前分支的别名。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <strong>创建</strong> 一个新分支，并不会自动切换到新分支中去。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921001503092.png" alt="image-20200921001503092"></p>
<p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --decorate</span><br><span class="line">f30ab (HEAD -&gt; master, testing) add feature <span class="comment">#32 - ability to add new formats to the central interface</span></span><br><span class="line">34ac2 Fixed bug <span class="comment">#1328 - stack overflow under certain conditions</span></span><br><span class="line">98ca9 The initial commit of my project</span><br></pre></td></tr></table></figure>

<p>当前 <code>master</code> 和 <code>testing</code> 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p>
<h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><p>要切换到一个已存在的分支，使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>

<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921003131064.png" alt="image-20200921003131064"></p>
<p>这样的实现方式有什么好处？当再次进行提交时：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921003330375.png" alt="image-20200921003330375"></p>
<p><code>testing</code>分支（<code>HEAD</code>所在分支）随着提交操作自动向前移动，但是<code>master</code>分支却没有移动，他仍然指向运行<code>git checkout</code>时所指的对象。再切回<code>master</code>分支看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921003745986.png" alt="image-20200921003745986"></p>
<p>可以看到<code>HEAD</code>指回了<code>master</code>分支。这条命令做了两件事，一是使<code>HEAD</code>指回<code>master</code>分支，二是将工作目录恢复成<code>master</code>分支所指向的快照内容。也就是说，现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p>
<p>此时<code>HEAD</code>指向<code>master</code>分支，如果此时进行修改并提交，而之前在<code>testing</code>分支上也进行了修改并提交，两次改动针对的是不同分支，此时提交历史就产生了分叉：你可以在不同的分支来回切换进行工作，在有需要的时候将他们合并起来，这些工作，需要的命令只有<code>branch</code>、<code>checkout</code>、<code>commit</code>。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921010301499.png" alt="image-20200921010301499"></p>
<p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<p>由于 git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p>
<p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p>在实际工作中，可能会有这样的经历：</p>
<ol>
<li>开发某个网站。</li>
<li>为实现某个新的用户需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>这时，出现一个很严重的bug需要紧急修补。那么这时候的流程应该是这样的：</p>
<ol>
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
<p>假设在<code>master</code>分支上已经有了一些提交：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921093629463.png" alt="image-20200921093629463"></p>
<p>这个时候，领导要你解决公司的bug追踪系统上的#53号问题，这个时候就需要新建一个分支并同时切换到那个分支上去，你可以使用带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里我们就使用我们的learngit本地仓库 进行演示</span></span><br><span class="line"><span class="comment"># 先确认工作区是干净的，然后新建分支</span></span><br><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch <span class="string">&#x27;iss53&#x27;</span></span><br></pre></td></tr></table></figure>

<p>它是这两条命令的简写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure>

<p>这时已经创建了一个新的分支iss53</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921094054060.png" alt="image-20200921094054060"></p>
<p>你继续在 <code>iss53</code>分支上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支 （也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改readme.txt文件，然后提交</span></span><br><span class="line">$ git commit -a -m <span class="string">&#x27;modify readme.txt add content study git branch&#x27;</span></span><br><span class="line">[iss53 0526e3d] modify readme.txt add content study git branch</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>分支随着工作的进展向前推进：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921094614566.png" alt="image-20200921094614566"></p>
<p>这时，<code>master</code>分支上又有一个紧急问题需要你来解决，那么这个时候，你可以直接切换回<code>master</code>分支解决问题即可，这里有一个前提：<strong>在你切换分支之前，保持好一个干净的状态，也就是确保你的工作目录和暂存区里没有未被提交的修改，避免和<code>master</code>分支产生冲突导致git不让你切换分支。</strong>切换至<code>master</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>切换回<code>master</code>分支之后，git会重置你的工作目录，使其恢复到你在这个分支最后一次提交的状态，当然你不用担心之前在<code>iss53</code>分支上的修改会消失，因为不同分支不会相互影响。接下来，要修复<code>master</code>分支上的问题，只需要再建立一个分支，在该分支上解决问题即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line"><span class="comment"># 修改 google.txt，并提交</span></span><br><span class="line">$ git commit -a -m <span class="string">&#x27;modify google.txt add content google voice&#x27;</span></span><br><span class="line">[hotfix d6c79ae] modify google.txt add content google voice</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921100559184.png" alt="image-20200921100559184"></p>
<p>可以在<code>hotfix</code>分支上进行测试，确保自己的修改无误，然后将<code>hotfix</code>分支合并到<code>master</code>分支部署到线上。合并分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating 6680bd4..d6c79ae</span><br><span class="line">Fast-forward</span><br><span class="line"> google.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>上述的合并信息中有 “快进（Fast-forward）”这个词。由于你想要合并的分支 <code>hotfix</code> 所指向的提交 <code>C4</code> 是你所在的提交 <code>C2</code> 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
<p><code>master</code> 被快进到 <code>hotfix</code>：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921101641681.png" alt="image-20200921101641681"></p>
<p>合并完成之后，<code>hotfix</code>分支就可以删除了，已经不需要它了（ <code>master</code> 分支和它已经指向了同一个位置），可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果未合并，但是想要强制删除分支，-d换成-D即可</span></span><br><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was d6c79ae).</span><br></pre></td></tr></table></figure>

<p>现在可以回到<code>iss53</code>分支继续之前的工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch <span class="string">&#x27;iss53&#x27;</span></span><br><span class="line"><span class="comment"># 再次修改readme.txt 文件，并提交</span></span><br><span class="line">$ git commit -a -m <span class="string">&#x27;modify readme.txt add content merge branch&#x27;</span></span><br><span class="line">[iss53 4418bd6] modify readme.txt add content merge branch</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921113511692.png" alt="image-20200921113511692"></p>
<p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 这和之前合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge iss53 <span class="comment"># 如果按照我的步骤来，肯定会出现下面的窗口</span></span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200927155746985.png" alt="image-20200927155746985"></p>
<p>这和之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，git 不得不做一些额外的工作。 出现这种情况的时候，git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921153724325.png" alt="image-20200921153724325"></p>
<p>和之前将分支指针向前推进所不同的是，git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200921154157859.png" alt="image-20200921154157859"></p>
<p>既然你的修改已经合并进来了，就不再需要 <code>iss53</code> 分支了。 可以在任务追踪系统中关闭此项任务，并删除这个分支。这里暂时不删除。</p>
<h2 id="合并分支遇到冲突"><a href="#合并分支遇到冲突" class="headerlink" title="合并分支遇到冲突"></a>合并分支遇到冲突</h2><p>现在我们再次创建一个分支，对<code>application.txt</code>文件进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line"><span class="comment"># 对application.txt文件进行修改并提交</span></span><br><span class="line">$ git commit -a -m <span class="string">&#x27;modify application.txt add android app&#x27;</span></span><br><span class="line">[hotfix 92f4c86] modify application.txt add android app</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"><span class="comment"># 切换回master分支，合并hotfix分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating 110aa9d..92f4c86</span><br><span class="line">Fast-forward</span><br><span class="line"> application.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>切换到<code>iss53</code>分支，同样对<code>application.txt</code>文件进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch <span class="string">&#x27;iss53&#x27;</span></span><br><span class="line"><span class="comment"># 对application.txt文件进行修改并提交</span></span><br><span class="line">$ git commit -a -m <span class="string">&#x27;modify application.txt add iphone&#x27;</span></span><br><span class="line">[iss53 cb202c2] modify application.txt add iphone</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个时候把<code>iss53</code>合并到<code>master</code>分支，就会产生合并冲突：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging application.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> application.txt</span><br><span class="line">Recorded preimage <span class="keyword">for</span> <span class="string">&#x27;application.txt&#x27;</span></span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p>此时 git 做了合并，但是没有自动地创建一个新的合并提交。 git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line">        both modified:   application.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子（打开<code>application.txt</code>文件）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">android app</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">iphone</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure>

<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支，因为你在运行 merge 命令的时候已经切换到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容修改成下面的样子来解决冲突：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application</span><br><span class="line">android app</span><br><span class="line">iphone</span><br></pre></td></tr></table></figure>

<p>这里解决冲突的方案是保留全部内容（当然实际工作中，要看自己的取舍，这里只是举个例子），并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，git 就会将它们标记为冲突已解决。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具（默认的很丑，可以到网上找一个），并带领你一步一步解决这些冲突。</p>
<p>冲突解决之后，git会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use <span class="string">&quot;git commit&quot;</span> to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">        modified:   application.txt</span><br></pre></td></tr></table></figure>

<p>如果觉得没有问题了，并且所有有冲突的文件都已经暂存了，这时可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有加 -m 的情况下</span></span><br><span class="line">Merge branch <span class="string">&#x27;iss53&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conflicts:</span></span><br><span class="line"><span class="comment">#       application.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It looks like you may be committing a merge.</span></span><br><span class="line"><span class="comment"># If this is not correct, please remove the file</span></span><br><span class="line"><span class="comment">#       .git/MERGE_HEAD</span></span><br><span class="line"><span class="comment"># and try again.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></span><br><span class="line"><span class="comment"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># All conflicts fixed but you are still merging.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#       modified:   application.txt</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>如果觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息， 添加一些细节给未来检视这个合并的读者一些帮助，告诉他们是如何解决合并冲突的，以及理由是什么</p>
<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p>之前已经创建、合并、删除了一些分支，现在来看看一些常用的分支管理工具。</p>
<p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  hotfix</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p> <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  hotfix 92f4c86 modify application.txt add android app</span><br><span class="line">  iss53  cb202c2 modify application.txt add iphone</span><br><span class="line">* master 27bc1f2 Merge branch <span class="string">&#x27;iss53&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  hotfix</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为之前已经合并了 <code>iss53</code> 分支和<code>hotfix</code>分支，所以现在看到它们在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p>
<p>如果存在未合并的分支，而你又想删除它，这个时候可以使用<code>git branch -D &lt;branchname&gt;</code>命令强制删除。</p>
<h2 id="Git远程分支"><a href="#Git远程分支" class="headerlink" title="Git远程分支"></a>Git远程分支</h2><p>先来了解两个名词：</p>
<ul>
<li>远程引用</li>
<li>远程跟踪分支</li>
</ul>
<h3 id="远程引用："><a href="#远程引用：" class="headerlink" title="远程引用："></a>远程引用：</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。可以通过 <code>git ls-remote &lt;remote&gt;</code> 来显式地获得远程引用的完整列表， 或者通过 <code>git remote show &lt;remote&gt;</code> 获得远程分支的更多信息。 然而，更常见的做法是利用远程跟踪分支。</p>
<h3 id="远程跟踪分支："><a href="#远程跟踪分支：" class="headerlink" title="远程跟踪分支："></a>远程跟踪分支：</h3><p>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p>
<p>远程跟踪分支 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名。例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支， 然而在服务器上的分支会以 <code>origin/iss53</code> 来表示。<strong>简单来说就是本地分支没有仓库名，远程分支是带有仓库名的。</strong></p>
<p>我们再来看一个例子，假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 git 服务器。 如果你从这里克隆，git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200922104438392.png" alt="image-20200922104438392"></p>
<p>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200922105108905.png" alt="image-20200922105108905"></p>
<p>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200922105220881.png" alt="image-20200922105220881"></p>
<p> 为了演示有多个远程仓库与远程分支的情况，假定你有另一个内部 git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目。 将这个远程仓库命名为 <code>teamone</code>，作为完整 URL 的缩写。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200922105617419.png" alt="image-20200922105617419"></p>
<p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200922105852517.png" alt="image-20200922105852517"></p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>在推送本地分支到远程仓库前，我们先把远程仓库克隆一份到本地备用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/tiangoubot/learngit.git learngit2</span><br></pre></td></tr></table></figure>

<p>把本地分支推送到远程仓库，可以使用<code>git push &lt;remote&gt; &lt;branch&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin iss53</span><br><span class="line">Enumerating objects: 12, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 851 bytes | 283.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 5), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (5/5), completed with 2 <span class="built_in">local</span> objects.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">&#x27;iss53&#x27;</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/tiangoubot/learngit/pull/new/iss53</span><br><span class="line">remote:</span><br><span class="line">To https://github.com/tiangoubot/learngit.git</span><br><span class="line"> * [new branch]      iss53 -&gt; iss53</span><br></pre></td></tr></table></figure>

<p>这里有些工作被简化了。 git 自动将 <code>iss53</code> 分支名字展开为 <code>refs/heads/iss53:refs/heads/iss53</code>， 那意味着，“推送本地的 <code>iss53</code> 分支来更新远程仓库上的 <code>iss53</code> 分支。” 你也可以运行 <code>git push origin iss53:iss53</code>， 它会做同样的事——也就是说“推送本地的 <code>iss53</code> 分支，将其作为远程仓库的 <code>iss53</code> 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>iss53</code>，可以运行 <code>git push origin iss53:devTest</code> 来将本地的 <code>iss53</code> 分支推送到远程仓库上的 <code>devTest</code> 分支。</p>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/iss53</code>，指向服务器的 <code>iss53</code> 分支的引用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 刚才我们把iss53分支推送到远程仓库了，现在，我们先进入刚才克隆下来备份的仓库，在根目录下打开git bash，然后执行</span></span><br><span class="line">$ git fetch origin</span><br><span class="line">remote: Enumerating objects: 27, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (27/27), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 23 (delta 9), reused 23 (delta 9), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (23/23), 2.12 KiB | 1024 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/tiangoubot/learngit</span><br><span class="line"> * [new branch]      iss53      -&gt; origin/iss53</span><br></pre></td></tr></table></figure>

<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>iss53</code> 分支——只有一个不可以修改的 <code>origin/iss53</code> 指针。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch <span class="comment"># 可以看到并没有iss53分支</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>你可以运行 <code>git merge origin/iss53</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>iss53</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b iss53 origin/iss53</span><br><span class="line">Switched to a new branch <span class="string">&#x27;iss53&#x27;</span></span><br><span class="line">Branch <span class="string">&#x27;iss53&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;iss53&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/iss53</code>。</p>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建“跟踪分支”（它跟踪的分支叫做“上游分支（例如： <code>origin/iss53</code>）”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>origin/master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。 这是一个十分常用的操作所以 git 提供了 <code>--track</code> 快捷方式：</p>
<p>先在GitHub上创建一个新的分支：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200927181822767.png" alt="image-20200927181822767"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch origin <span class="comment"># 从远程仓库拉取数据</span></span><br><span class="line">From https://github.com/tiangoubot/learngit</span><br><span class="line"> * [new branch]      serverfix  -&gt; origin/serverfix</span><br><span class="line"><span class="comment"># 设置跟踪分支</span></span><br><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Switched to a new branch <span class="string">&#x27;serverfix&#x27;</span></span><br><span class="line">Branch <span class="string">&#x27;serverfix&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;serverfix&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 git 就会为你创建一个跟踪分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;serverfix&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;sf&#x27;</span></span><br></pre></td></tr></table></figure>

<p>此时，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上游快捷方式<br>当设置好跟踪分支后，可以通过简写 <code>@&#123;upstream&#125;</code> 或 <code>@&#123;u&#125;</code> 来引用它的上游分支。 所以在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，可以使用 <code>git merge @&#123;u&#125;</code> 命令来取代 <code>git merge origin/master</code>。</p>
</blockquote>
<p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<p>假如你看到了如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should <span class="keyword">do</span> it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入本地，同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p>
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch --all; git branch -vv</span><br></pre></td></tr></table></figure>

<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个跟踪分支。</p>
<p> <code>git pull</code> 命令会将本地仓库代码更新至远程仓库中最新的版本，简单粗暴。而 <code>fetch</code> 命令只是将本地仓库没有而远程仓库有的代码拉取到本地，你需要使用 <code>merge</code> 命令进行合并，如果本地代码与远程仓库的代码有冲突，你需要解决冲突之后才能进行合并，这样可以避免一些莫名其妙的问题。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假如你想要删除远程分支，可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/tiangoubot/learngit.git</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>

<p>基本上这个命令做的只是从服务器上移除这个指针。 git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<p>如果误删了远程分支，可以按照以下步骤恢复：</p>
<ol>
<li><p>查看reflog，找到最后一次commitid</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog --date=iso</span><br></pre></td></tr></table></figure>

<p><code>reflog</code>是<strong>reference log</strong>的意思，也就是引用log，记录HEAD在各个分支上的移动轨迹。选项 <code>--date=iso</code>，表示以标准时间格式展示。这里你肯定会问，为什么不用git log？git log是用来记录当前分支的commit log，分支都删除了，找不到commit log了。</p>
<p>找到目标分支最后一次的commitid，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog --date=iso</span><br><span class="line">5ddc9cb (HEAD -&gt; testing) HEAD@&#123;2020-09-22 11:27:29 +0800&#125;: checkout: moving from master to testing</span><br><span class="line">aaf35a8 (master) HEAD@&#123;2020-09-22 11:23:15 +0800&#125;: <span class="built_in">clone</span>: from https://github.com/tiangoubot/gitTest.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>检出分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b recovery_branch_name commitid</span><br></pre></td></tr></table></figure>

<p>检出分支，本地就有分支了。</p>
</li>
<li><p>push到远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin recovery_branch_name</span><br></pre></td></tr></table></figure>

<p>至此，恢复完成。</p>
</li>
</ol>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928165826202.png" alt="image-20200928165826202"></p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200923165435138.png"></p>
<p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。<code>rebase</code>有人把它翻译成“变基”。</p>
<h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>之前的分支合并中有一个例子，你会看到开发任务分叉到两个不同的分支，又各自提交了更新：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928170407752.png" alt="image-20200928170407752"></p>
<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928170709177.png" alt="image-20200928170709177"></p>
<p>另一种方法：提取在<code>C4</code>中打的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。这个操作，在git中就叫做<strong>变基（rebase）</strong>。你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移到另一分支上。</p>
<p>在这个例子中，你可以切换到<code>experiment</code>分支上，然后将它变基到<code>master</code>分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>

<p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928171433525.png" alt="image-20200928171433525"></p>
<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928171547867.png" alt="image-20200928171547867"></p>
<p>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。<code>merge</code>会保留更多的提交历史，所以查看提交历史（使用<code>git log --pretty=formt:&quot;%h %s&quot; --graph</code>命令可以看到分叉情况），会看到很多的分叉，而使用<code>rebase</code>，提交历史就只是一条直线。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<h3 id="有趣的变基例子"><a href="#有趣的变基例子" class="headerlink" title="有趣的变基例子"></a>有趣的变基例子</h3><p>假如你创建了一个分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928172718863.png" alt="image-20200928172718863"></p>
<p>你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项， 选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上整合：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure>

<p>以上命令的意思是：“取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上整合，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样”。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928173415142.png" alt="image-20200928173415142"></p>
<p>现在可以快进合并 <code>master</code> 分支了。（如图快进合并 <code>master</code> 分支，使之包含来自 <code>client</code> 分支的修改）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge client</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928173618435.png" alt="image-20200928173618435"></p>
<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 命令可以直接将主题分支 （即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。 这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase master server</span><br></pre></td></tr></table></figure>

<p>如图将 <code>server</code> 中的修改变基到 <code>master</code> 上 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928173943542.png" alt="image-20200928173943542"></p>
<p>然后就可以快进合并主分支 <code>master</code> 了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge server</span><br><span class="line"><span class="comment"># 合并后 client和server分支都不需要了，可以删除</span></span><br><span class="line">$ git branch -d client</span><br><span class="line">$ git branch -d server</span><br></pre></td></tr></table></figure>

<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928174117268.png" alt="最终的提交历史"></p>
<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p><strong>要使用变基，就要遵守一条准则：只对尚未推送或分享给别人的本地修改执行变基操作清理提交历史，不对已推送至别处的提交执行变基操作</strong>。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同事因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928175227470.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发"></p>
<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928175324328.png" alt="抓取别人的提交，合并到自己的开发分支"></p>
<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928175416569.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交"></p>
<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928175512283.png" alt="你将相同的内容又合并了一次，生成了一个新的提交"></p>
<p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p>
<h3 id="变基解决变基"><a href="#变基解决变基" class="headerlink" title="变基解决变基"></a>变基解决变基</h3><p>如果真的遇到了类似的问题，那咋办啊？</p>
<p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。</p>
<p>如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>
<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
<p>举个例子，如果遇到前面提到的有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交那种情境（也就是上面的情境）：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928175512283.png"></p>
<p>如果我们不是执行合并（也就是没有C8的提交），而是执行 <code>git rebase teamone/master</code>, Git 将会：</p>
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
<p>从而我们将得到与你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示：</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200928181907257.png" alt="在一个被变基然后强制推送的分支上再次执行变基"></p>
<p>要想上述方案有效，还需要对方在变基时确保 <code>C4&#39;</code> 和 <code>C4</code> 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 <code>C4</code> 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>
<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p>
<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p>
<p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了。</p>
<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p>
<h3 id="变基-VS-合并"><a href="#变基-VS-合并" class="headerlink" title="变基 VS 合并"></a>变基 VS 合并</h3><p>了解了变基和合并，肯定会有疑惑，都能达到一样的目的，那哪种方式更好呢？</p>
<p>有人认为，仓库的提交历史即是<strong>记录实际发生过什么</strong>，它是针对历史的文档，本身就有价值，不能乱改。即使由合并产生的提交历史是一团糟，这些痕迹也应该被保留下来，让后人能够查阅。</p>
<p>还有人认为，提交历史是<strong>项目过程中发生的事</strong>，不必每件事都记录的那么清楚，可以允许丢失一些无关紧要的细节，保留主要的脉络就行了。</p>
<p>其实这个问题没有标准答案， Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
<p><strong>总的原则就是：只对尚未推送或分享给别人的本地修改执行变基操作清理提交历史，不对已推送至别处的提交执行变基操作。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于要结束了，但是git还没有真正的学完，看完这些，只是了解了一些git比较基础的知识，跟多高级的操作，还需要继续学习，但是也勉强够用了，后续如果遇到一些坑，我会重新写一些文章来进行记录。</p>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001133250303.png" alt="image-20201001133250303"></p>
<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p><strong>Git作为我们最常用的版本控制工具，多了解并熟悉一些命令，将能节省很多时间</strong></p>
<p>关于git，首先需要了解几个名词，如下：</p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote repository：远程仓库</li>
</ul>
<p><img data-src="/2020/09/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001133439592.png" alt="image-20201001133439592"></p>
<h2 id="新建代码库（本地仓库）"><a href="#新建代码库（本地仓库）" class="headerlink" title="新建代码库（本地仓库）"></a>新建代码库（本地仓库）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="暂存-删除文件"><a href="#暂存-删除文件" class="headerlink" title="暂存/删除文件"></a>暂存/删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<h2 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h2 id="查看提交历史-1"><a href="#查看提交历史-1" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动，但是不自动合并</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h2 id="撤销操作-1"><a href="#撤销操作-1" class="headerlink" title="撤销操作"></a>撤销操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
